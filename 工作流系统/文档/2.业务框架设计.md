## 1、业务框架概念

### 1.1、业务框架理解

含义：快速实现工作流系统的技术。例如：微软提供的Microsoft.AspNetCore.App和Microsoft.NETCore.App。就是框架。包括我们自己封装的小组件，都可以叫做框架。

![img](https://cdn.nlark.com/yuque/0/2026/png/42432244/1769522902473-ed7de657-31e1-44c3-8435-b6dfe92bde69.png)

### 1.2、业务框架背景

企业在开发工作流系统的时候。如果缺乏框架，工作流系统，需要从前端到后端。再到数据库。全部都需要我们自己来实现。 效率非常低下。所以为了提升开发工作流系统效率。因此将原有项目所有用都的技术全部封装起来。封装起来形成的模块，就叫做框架。

好处：提升工作流系统开发效率。

### 1.3、业务框架边界

含义：业务框架边界，就是工作流系统架构。架构如下：

![img](https://cdn.nlark.com/yuque/0/2026/png/42432244/1769522902496-bf818015-04d0-441e-be2a-d0d1436cbea6.png)

例如：将工作流前端、工作流后端、工作流数据库全部封装一遍。形成的一套东西。就是工作流系统框架

# 2、业务框架落地

业务框架主要涉及要后端框架。

## 2.1通用结果

把WebAPI Controller里Action产生的结果，封装起来。

当结果类型过多。导致前端对接接口的时候，出现判断混乱的问题。因此创建CommonResult类处理Action的结果。

![img](https://cdn.nlark.com/yuque/0/2026/png/42432244/1769523256049-5b1b991d-7c9e-4066-95ce-76d49f16f590.png)

```plain
public class CommonResult
{
    public string ErrorNo { set; get; } // 结果状态编号
    public string ErrorInfo { set; get; } //  结果状态信息
    public dynamic Result { set; get; } // 代表所有的Action结果
}
public CommonResult GetIActionResult1()
{
    CommonResult result = new CommonResult()
    {
        ErrorNo = "0",
        ErrorInfo = "成功",
        Result = "这是一个IActionResult返回值的示例"
    };
    return result;
}
```

这种写法是每个Controller方法的返回值都是CommonResult。还有一种设置全局，即无需将返回值设为CommonResult的写法：

```plain
public async Task OnResultExecutionAsync(ResultExecutingContext context,
    ResultExecutionDelegate next)
{
    // 1、获取Action结果
    IActionResult actionResult = context.Result;

    // 2、判断Action结果类型 ObjectResult
    if (actionResult is ObjectResult objectResult)
    {
        // 2.1、获取结果值
        object result = objectResult.Value;

        // 2.1.1、结果值判断
        if (result is CommonResult common)
        {
            // 2.3、结果返回
            context.Result = new JsonResult(common);
        }
        else
        {
            // 2.2、结果包装
            CommonResult commonResult = new CommonResult();
            commonResult.ErrorNo = "0";
            commonResult.Result = result;

            // 2.3、结果返回
            context.Result = new JsonResult(commonResult);
        }
    }
    // 3、判断Action结果类型 EmptyResult
    else if (actionResult is EmptyResult emptyResult)
    {
        //3.1、空结果包装
        CommonResult commonResult = new CommonResult();
        commonResult.ErrorNo = "0";
        commonResult.Result = "无结果";

        // 3.2 、结果返回
        context.Result = new JsonResult(commonResult);
    }
    // 4、判断Action结果类型 JsonResult
    else if (actionResult is JsonResult jsonResult)
    {
        // 4.1、JsonResult包装
        CommonResult commonResult = new CommonResult();
        commonResult.ErrorNo = "0";
        commonResult.Result = jsonResult.Value; // Json值

        // 4.2、结果返回
        context.Result = new JsonResult(commonResult);
    }
    // 5、判断Action结果类型 StatusCodeResult
    else if (actionResult is StatusCodeResult statusCodeResult)
    {
        // 4.1、StatusCodeResult包装
        CommonResult commonResult = new CommonResult();
        commonResult.ErrorNo = "0";
        commonResult.Result = statusCodeResult.StatusCode; // 状态码

        // 4.2、结果返回
        context.Result = new JsonResult(commonResult);
    }

    // 3、下一个过滤器
    await next();
}
```

然后在Program设如下配置：

```plain
builder.Services.AddControllers(options =>
{
    // 1、配置CommonResultFilter
    options.Filters.Add<CommonResultFilter>();
});
```

绝大部分返回值类型都是ObjectResult，如果是其他的，如JsonResult，EmptyResult就要单独设置。

## 2.2 通用异常

```plain
public class CommonException : Exception
{
    public string ErrorNo { get; set; } // 异常编号
    public string ErrorInfo { get; set; }  // 抽象 message
}
```

定义这个异常类后，对异常需要定义异常类，并将报错信息赋值给它并抛出，如果要通用异常。

```plain
[HttpGet("GetImplementedException")]
public void GetImplementedException()
{
    CommonException exception = new()
    {
        ErrorNo = "1",
        ErrorInfo = "这是一个已实现的异常示例"
    };
    throw exception;
}
/// <summary>
/// 通用异常包装
/// </summary>
public class CommonExceptionFilter : IExceptionFilter
{
    /// <summary>
    /// 1、实现通用异常包装
    /// </summary>
    /// <param name="context"></param>
    /// <exception cref="NotImplementedException"></exception>
    public void OnException(ExceptionContext context)
    {
        // 1、获取异常
        Exception exception = context.Exception;

        // 1.1、异常判断
        if (exception is CommonException common)
        {
            // 1.1.1、通用异常结果包装
            CommonExceptionResult commonExceptionResult = new CommonExceptionResult();
            commonExceptionResult.ErrorNo = common.ErrorNo;
            commonExceptionResult.ErrorInfo = common.ErrorInfo;
            commonExceptionResult.ErrorReason = common.StackTrace;

            // 1.1.2、通用异常结果返回
            context.Result = new JsonResult(commonExceptionResult);
        }
        else
        {
            // 2、异常包装
            CommonException commonException = new CommonException();
            commonException.ErrorNo = "-1"; // 异常状态
            commonException.ErrorInfo = exception.Message;
            //commonException.ErrorReason = exception.StackTrace;

            // 3、异常包装返回
            context.Exception = commonException;

            // 4、通用异常结果包装
            CommonExceptionResult commonExceptionResult = new CommonExceptionResult();
            commonExceptionResult.ErrorNo = commonException.ErrorNo;
            commonExceptionResult.ErrorInfo = commonException.ErrorInfo;
            commonExceptionResult.ErrorReason = commonException.StackTrace;

            // 5、通用异常结果返回
            context.Result = new JsonResult(commonExceptionResult);
        }

    }
}
builder.Services.AddControllers(options =>
{
    // 1、配置CommonResultFilter
    options.Filters.Add<CommonResultFilter>();
    // 2、配置CommonExceptionFilter
    options.Filters.Add<CommonExceptionFilter>();
});
```

配置了之后，每个异常都会去执行CommonExceptionFilter类并返回CommonExceptionResult（异常结果类）。

## 2.3 通用Controller

把WebAPI Controller封装起来。用户封装所有控制器中相同的依赖。

```plain
/// <summary>
/// 通用控制器
/// </summary>
public abstract class CommonController<T> : ControllerBase
{
    protected ILogger<T> _logger { get; }

    public CommonController(ILogger<T> logger)
    {
        _logger = logger;
    }
}
```

在控制器中继承通用控制器，就能够使用_logger属性。

## 2.4 通用Json

默认的Json转换会改变字段的大小写，通用Json把WebAPI Controller Action产生的结果，全部转化为模型字段定义的格式。

写法即在Program里加上代码：

```plain
builder.Services.AddControllers(options =>
{
    // 1、配置CommonResultFilter
    options.Filters.Add<CommonResultFilter>();
    // 2、配置CommonExceptionFilter
    options.Filters.Add<CommonExceptionFilter>();
}).AddJsonOptions(options =>
{
    // 3、配置通用Json格式
    options.JsonSerializerOptions.PropertyNamingPolicy = null;
});
```

## 2.5 通用模块