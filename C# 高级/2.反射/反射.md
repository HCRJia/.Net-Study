# 反射的定义

C# 经过编译后会得到中间产物：程序集，常见的程序集包括两种：可执行文件（.exe文件）和 类库文件（.dll文件）。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759841992636-4f3ce258-3bb8-4a2d-95dd-098a1d9b00e5.png)

程序集中保存了大量元数据，元数据是用于描述数据的数据，程序的类、类的方法、变量都属于程序的元数据，保存在程序集当中。使用反射时，无需知道具体的代码。
	反射的功能就离不开上面两点概念。简单来说，反射是程序正在运行时，可以查看自身或者其他程序集元数据的行为。也就是说，反射是直接读取项目的dll和exe文件。我们能通过反射，直接更改程序集的成员、调用方法甚至实例化，甚至可以无视各种关键字。

# 反射的场景

我们准备了一组类库：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759841964297-5a2cc9ae-0b59-437d-a33e-f16c43137467.png)

```csharp
namespace DB.Interface
{
    /// <summary>
    /// 数据访问类抽象
    /// </summary>
    public interface IDBHelper
    {
        void Query();
    }
}
using DB.Interface;
namespace DB.MySql
{
    public class MySqlHelper : IDBHelper
    {
        public MySqlHelper()
        {
            Console.WriteLine("{0}被构造", this.GetType().Name);
        }


        public void Query()
        {
            Console.WriteLine("{0}.Query", this.GetType().Name);
        }
    }
}
```

，上面只列了MySqlHelper.cs的代码，别的同理。在编译后，在项目的bin里的debug文件夹下，会生成dll和exe文件

```csharp
// 反射
//有三种不同的加载方法
{
    Assembly assembly = Assembly.Load("DB.MySql");
    //1 动态加载 一个完整dll名称不需要后缀  从exe所在的路径进行查找
    Assembly assembly1 = Assembly.LoadFile("D:\\Code\\.Net-Study\\C# 高级\\2.反射\\Reflection\\Reflection\\bin\\Debug\\net8.0\\DB.MySql.dll");
    Assembly assembly2 = Assembly.LoadFrom("DB.MySql.dll");
    Assembly assembly3 = Assembly.LoadFrom("D:\\Code\\.Net-Study\\C# 高级\\2.反射\\Reflection\\Reflection\\bin\\Debug\\net8.0\\DB.MySql.dll");

    foreach (var type in assembly.GetTypes())
    {
        //type.IsGenericType
        Console.WriteLine(type.Name);
        foreach (var method in type.GetMethods())
        {
            Console.WriteLine(method.Name);
        }
    }
}
```

这个循环就是获取了DB.MySql里的所有的方法，其中MySqlHelper是自己定义的，剩下的都是自带的方法。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759742430140-855f1047-e3af-4182-915a-b0001996bcfc.png)

在开发中，若是遇到需要调整类库，但方法名一样的情况，改代码的话就需要重新编译和发布，而反射只需要修改配置项。

```csharp
IDBHelper iDBHelper = new MySqlHelper();
//IDBHelper iDBHelper = new SqlServerHelper();
iDBHelper.Query();

//MySqlHelper换成SqlServerHelper 就必须修改现有代码 重新编译 发布
```

# 反射的使用

反射中，有个重要的类就是Type，它是反射功能的基础，type可以用来获取方法，变量等，下面是方法的一种实现。

```csharp
Console.WriteLine("************************Reflection************************");
Assembly assembly = Assembly.Load("DB.MySql");//1 动态加载
Type type = assembly.GetType("DB.MySql.MySqlHelper");//2 获取类型 完整类型名称
object oDBHelper = Activator.CreateInstance(type);//3 创建对象 仍然会实例化对象
IDBHelper iDBHelper = oDBHelper as IDBHelper;//4 类型转换  不报错，类型不对就返回null
iDBHelper.Query();//5 方法调用
```

在这段代码中不能直接使用oDBHelper.Query()，虽然DB.MySql.MySqlHelper中有Query方法，但编译器是把oDBHelper看成object类型，解决方法有几种：

1.将oDBHelper转换成IDBHelper类型，进行类型转换。

2.使用dynamic类型，这个类型编译器不会检查，运行是才会检查语法。

还有Invoke来调用直接方法，这个下面在讲。

在前台对后台的调用中，就用到了反射。比如http://localhost:9099/home/index，便是调用了homeControll中的index方法。

反射使程序具有可配置和可扩展性：

## 可配置性

我们可以把上面的代码封装一下，并将DB.MySql.MySqlHelper写到配置文件App.config文件中

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759817655318-5e3b9954-efa7-4417-8c1c-fe83754b227c.png)

```csharp
public class SimpleFactory
{
    private static string IDBHelperConfig = ConfigurationManager.AppSettings["IDBHelperConfig"];
    private static string DllName = IDBHelperConfig.Split(',')[1];
    private static string TypeName = IDBHelperConfig.Split(',')[0];
    public static IDBHelper CreateInstance()
    {
        Assembly assembly = Assembly.Load(DllName);
        Type type = assembly.GetType(TypeName);
        object oDBHelper = Activator.CreateInstance(type);
        IDBHelper iDBHelper = oDBHelper as IDBHelper;
        return iDBHelper;
    }
}
```

这串代码就可以读取配置文件中的IDBHelperConfig，获取它的值。其中，要使用ConfigurationManager，需要安装System.Configuration.ConfigurationManager的包。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759805896051-d6892d93-aae9-4a16-aab2-adef8f5be651.png)

我们只需要在编译后的debug文件中，找到Reflection.dll.config文件，修改其中的代码，然后直接运行.exe文件。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850578360-abcf846f-21d6-4bcc-864f-7ae81c99ddb7.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850610053-70c42fae-2e96-4496-94b5-73532310c44e.png)

可以看到，输出结果发生了变化。

## 可扩展性

我们在项目中新建一个类库：DB.Oracle，其中的方法名和上面的类库类似，然后编译。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850647343-da4c9400-8d04-4158-9604-5d9290759171.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850728718-aaf6e530-c63f-4c89-a09b-7b6cc2c3e171.png)

我们只需要将DB.Oracle里dubug里的.dll文件复制到Reflection的dubug里，修改配置项，运行.exe文件：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850830301-7c0adcf3-1f6c-4657-8fd4-fcb50d5a3004.png)

便可以得到Oracle的结果。所以反射的动态加载和动态创建对象，以及配置文件结合，可以使项目在管理上更加方便。

## 重载的反射

```csharp
public ReflectionTest()
{
    Console.WriteLine("这里是{0}无参数构造函数", this.GetType());
}

public ReflectionTest(string name)
{
    Console.WriteLine("这里是{0} 有参数构造函数", this.GetType());
}

public ReflectionTest(int id)
{
    Console.WriteLine("这里是{0} 有参数构造函数", this.GetType());
}
```

新建一个类：ReflectionTest.cs，同样的方法名不同的参数，通过反射也可以准确的调用。

```csharp
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.ReflectionTest");
foreach (ConstructorInfo ctor in type.GetConstructors())
{
    Console.WriteLine(ctor.Name);
    foreach (var parameter in ctor.GetParameters())
    {
        Console.WriteLine(parameter.ParameterType);
    }
}
object oTest1 = Activator.CreateInstance(type);
object oTest2 = Activator.CreateInstance(type, new object[] { 123 });
object oTest3 = Activator.CreateInstance(type, new object[] { "你好，世界" });
```

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760018443599-13cacbaa-8555-4803-986b-f42bce9fbe67.png)

中间的循环是获取了所有的参数，可以看到反射可以正确获取所有的参数，并正确调用。

## 反射破坏单例

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760018870798-4f36eb3c-aaba-44fc-a682-32e740976a8f.png)

我们设置一个单例，该类的构造函数是private，正常使用Singleton singletonA = (Singleton)Activator.CreateInstance(type); 是无法访问的，但是CreateInstance还有一个参数：nonPublic。这个参数传new，便可以访问私有方法。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760019016559-d34e9231-d844-4e86-b8b3-5fbc168b7131.png)

```csharp
Singleton singletonA = (Singleton)Activator.CreateInstance(type, true);
Singleton singletonB = (Singleton)Activator.CreateInstance(type, true);
```

​	这两行代码不会报错，且singletonA和singletonB是两个不同的实例，而一般的单例只能有一个实例。因此可以称为破坏了单例。

## 方法的调用

我们前面提到，还有一种方法，不需要类型转换，Invoke来调用直接方法。

```csharp
MethodInfo methodInfo = type.GetMethod("Query");
methodInfo.Invoke(oDBHelper, null);//6 反射调用方法
```

可以看一些更详细的例子：

```csharp
public void Show1()
{
    Console.WriteLine("这里是{0}的Show1", this.GetType());
}

public void Show2(int id)
{

    Console.WriteLine("这里是{0}的Show2", this.GetType());
}

public void Show3()
{

    Console.WriteLine("这里是{0}的Show3_1", this.GetType());
}

public void Show3(int id)
{

    Console.WriteLine("这里是{0}的Show3_2", this.GetType());
}

public void Show3(int id, string name)
{
    Console.WriteLine("这里是{0}的Show3_3", this.GetType());
}

private void Show4(string name)
{
    Console.WriteLine("这里是{0}的Show4", this.GetType());
}

public static void Show5(string name)
{
    Console.WriteLine("这里是{0}的Show5", typeof(ReflectionTest));
}
```

上面构造的方法涵盖了无参方法，有参方法，方法重载，私有方法，静态方法，下面来写具体的调用。

```csharp
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.ReflectionTest");
object oTest = Activator.CreateInstance(type);

{
    MethodInfo method = type.GetMethod("Show1");
    method.Invoke(oTest, null);
}
{
    MethodInfo method = type.GetMethod("Show2");
    method.Invoke(oTest, new object[] { 123 });
}
{
    MethodInfo method = type.GetMethod("Show3", new Type[] { });
    method.Invoke(oTest, null);
}
{
    MethodInfo method = type.GetMethod("Show3", new Type[] { typeof(int) });  // 需要在后面声明参数类型
    method.Invoke(oTest, new object[] { 123 });
}
{
    MethodInfo method = type.GetMethod("Show3", new Type[] { typeof(int), typeof(string) });
    method.Invoke(oTest, new object[] { 234, "测试2" });
}
{
    MethodInfo method = type.GetMethod("Show5");
    method.Invoke(oTest, new object[] { "张三" });//静态方法实例可以要
    method.Invoke(null, new object[] { "张三" });//静态方法实例也可以不要
}
{
    //调用私有方法
    Console.WriteLine("&&&&&&&&&&&&&&&&&&&&私有方法&&&&&&&&&&&&&&&&&&&");
    Assembly assembly = Assembly.Load("DB.SqlServer");
    Type type = assembly.GetType("DB.SqlServer.ReflectionTest");
    object oTest = Activator.CreateInstance(type);
    var method = type.GetMethod("Show4", BindingFlags.Instance | BindingFlags.NonPublic);
    method.Invoke(oTest, new object[] { "我是李四" });
}
```

上面就是对各种方法的调用，通过type.GetMethod()方法获取对应dll里的方法，除了方法名以外，还可以提供参数，通过method.Invoke()来调用方法。

## 泛型的反射

下面，我们写一个泛型的类，再使用反射去调用。

```csharp
public class GenericClass<T, W, X>
{
    public void Show(T t, W w, X x)
    {
        Console.WriteLine("t.type={0},w.type={1},x.type={2}", t.GetType().Name, w.GetType().Name, x.GetType().Name);
    }
}

public class GenericDouble<T>
{
    public void Show<W, X>(T t, W w, X x)
    {
        Console.WriteLine("t.type={0},w.type={1},x.type={2}", t.GetType().Name, w.GetType().Name, x.GetType().Name);
    }
}
{
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.GenericClass`3");
//GenericClass<string, int, DateTime> genericClass = new GenericClass<string, int, DateTime>();
//object oGeneric = Activator.CreateInstance(type);
Type typeMake = type.MakeGenericType(new Type[] { typeof(string), typeof(int), typeof(DateTime) });
object oGeneric = Activator.CreateInstance(typeMake);
}
{
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.GenericDouble`1").MakeGenericType(typeof(int));
object oObject = Activator.CreateInstance(type);
MethodInfo method = type.GetMethod("Show").MakeGenericMethod(typeof(string), typeof(DateTime));
method.Invoke(oObject, new object[] { 345, "这是一个测试", DateTime.Now });
}
```

这里面要注意，调用泛型方法是要加上`参数数量，如`3，然后用MakeGenericType来确定方法类型。然后继续使用Invoke来调用该泛型的方法。

# 反射的优缺点

## 优点

反射最大的优点就是可以动态地创建对象、调用方法、访问字段和属性，这为编写灵活和动态的代码提供了极大的便利，方便项目的管理与后续的维护。

## 缺点

反射在代码的编写上比较麻烦，并且会绕过编译器的检查，反射的性能也比一般的调用要慢。

我们可以编写一下代码测试速度：

```csharp
public static void Show()
{
    Console.WriteLine("*******************Monitor*******************");
    long commonTime = 0;
    long reflectionTime1 = 0;
    long reflectionTime2 = 0;
    {
        Stopwatch watch = new Stopwatch();
        watch.Start();
        for (int i = 0; i < 10000000; i++)
        {
            IDBHelper iDBHelper = new SqlServerHelper();
            iDBHelper.Query();
        }
        watch.Stop();
        commonTime = watch.ElapsedMilliseconds;
    }
    {
        Stopwatch watch = new Stopwatch();
        watch.Start();
        for (int i = 0; i < 10000000; i++)
        {
            Assembly assembly = Assembly.Load("DB.SqlServer");//1 动态加载
            Type dbHelperType = assembly.GetType("DB.SqlServer.SqlServerHelper");//2 获取类型
            object oDBHelper = Activator.CreateInstance(dbHelperType);//3 创建对象
            IDBHelper dbHelper = (IDBHelper)oDBHelper;//4 接口强制转换
            dbHelper.Query();//5 方法调用
        }
        watch.Stop();
        reflectionTime1 = watch.ElapsedMilliseconds;
    }
    {
        Stopwatch watch = new Stopwatch();
        watch.Start();
        Assembly assembly = Assembly.Load("DB.SqlServer");//1 动态加载
        Type dbHelperType = assembly.GetType("DB.SqlServer.SqlServerHelper");//2 获取类型
        for (int i = 0; i < 10000000; i++)
        {
            //Assembly assembly = Assembly.Load("DB.SqlServer");//1 动态加载
            //Type dbHelperType = assembly.GetType("DB.SqlServer.SqlServerHelper");//2 获取类型
            object oDBHelper = Activator.CreateInstance(dbHelperType);//3 创建对象
            IDBHelper dbHelper = (IDBHelper)oDBHelper;//4 接口强制转换
            dbHelper.Query();//5 方法调用
        }
        watch.Stop();
        reflectionTime2 = watch.ElapsedMilliseconds;
    }

    Console.WriteLine("commonTime={0} reflectionTime1={1} reflectionTime2={2}", commonTime, reflectionTime1, reflectionTime2);
}
```

在这个例子中，分别用直接调用类和反射调用类，其中反射把dll加在的代码分别放在循环内循环外，进行循环10000000。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760255564434-948a4312-975b-4136-bc95-8ebf5e6f0a7f.png)

这个结果可以看到commonTime是78ms，reflectionTime1是9614，差了一百多倍，但reflectionTime2又是103，跟commonTime差不多。

因此，反射性能问题确实存在，但这是循环10000000次的结果，实际项目中不会循环这么多，所以无需因为性能问题去避开反射。并且比较reflectionTime1和reflectionTime2，可以看到性能大部分花在了加在dll和获取类型上面，项目在运行时，可以先进行动态加载，预处理，这样可以最大幅度减少反射的性能问题。