# 反射的定义

C# 经过编译后会得到中间产物：程序集，常见的程序集包括两种：可执行文件（.exe文件）和 类库文件（.dll文件）。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759841992636-4f3ce258-3bb8-4a2d-95dd-098a1d9b00e5.png)

程序集中保存了大量元数据，元数据是用于描述数据的数据，程序的类、类的方法、变量都属于程序的元数据，保存在程序集当中。使用反射时，无需知道具体的代码。
	反射的功能就离不开上面两点概念。简单来说，反射是程序正在运行时，可以查看自身或者其他程序集元数据的行为。也就是说，反射是直接读取项目的dll和exe文件。我们能通过反射，直接更改程序集的成员、调用方法甚至实例化，甚至可以无视各种关键字。

# 反射的场景

我们准备了一组类库：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759841964297-5a2cc9ae-0b59-437d-a33e-f16c43137467.png)

```csharp
namespace DB.Interface
{
    /// <summary>
    /// 数据访问类抽象
    /// </summary>
    public interface IDBHelper
    {
        void Query();
    }
}
using DB.Interface;
namespace DB.MySql
{
    public class MySqlHelper : IDBHelper
    {
        public MySqlHelper()
        {
            Console.WriteLine("{0}被构造", this.GetType().Name);
        }


        public void Query()
        {
            Console.WriteLine("{0}.Query", this.GetType().Name);
        }
    }
}
```

，上面只列了MySqlHelper.cs的代码，别的同理。在编译后，在项目的bin里的debug文件夹下，会生成dll和exe文件

```csharp
// 反射
//有三种不同的加载方法
{
    Assembly assembly = Assembly.Load("DB.MySql");
    //1 动态加载 一个完整dll名称不需要后缀  从exe所在的路径进行查找
    Assembly assembly1 = Assembly.LoadFile("D:\\Code\\.Net-Study\\C# 高级\\2.反射\\Reflection\\Reflection\\bin\\Debug\\net8.0\\DB.MySql.dll");
    Assembly assembly2 = Assembly.LoadFrom("DB.MySql.dll");
    Assembly assembly3 = Assembly.LoadFrom("D:\\Code\\.Net-Study\\C# 高级\\2.反射\\Reflection\\Reflection\\bin\\Debug\\net8.0\\DB.MySql.dll");

    foreach (var type in assembly.GetTypes())
    {
        //type.IsGenericType
        Console.WriteLine(type.Name);
        foreach (var method in type.GetMethods())
        {
            Console.WriteLine(method.Name);
        }
    }
}
```

这个循环就是获取了DB.MySql里的所有的方法，其中MySqlHelper是自己定义的，剩下的都是自带的方法。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759742430140-855f1047-e3af-4182-915a-b0001996bcfc.png)

在开发中，若是遇到需要调整类库，但方法名一样的情况，改代码的话就需要重新编译和发布，而反射只需要修改配置项。

```csharp
IDBHelper iDBHelper = new MySqlHelper();
//IDBHelper iDBHelper = new SqlServerHelper();
iDBHelper.Query();

//MySqlHelper换成SqlServerHelper 就必须修改现有代码 重新编译 发布
```

# 反射的使用

反射中，有个重要的类就是Type，它是反射功能的基础，type可以用来获取方法，变量等，下面是方法的一种实现。

```csharp
Console.WriteLine("************************Reflection************************");
Assembly assembly = Assembly.Load("DB.MySql");//1 动态加载
Type type = assembly.GetType("DB.MySql.MySqlHelper");//2 获取类型 完整类型名称
object oDBHelper = Activator.CreateInstance(type);//3 创建对象 仍然会实例化对象
IDBHelper iDBHelper = oDBHelper as IDBHelper;//4 类型转换  不报错，类型不对就返回null
iDBHelper.Query();//5 方法调用
```

在这段代码中不能直接使用oDBHelper.Query()，虽然DB.MySql.MySqlHelper中有Query方法，但编译器是把oDBHelper看成object类型，解决方法有两种：

1.将oDBHelper转换成IDBHelper类型，进行类型转换。

2.使用dynamic类型，这个类型编译器不会检查，运行是才会检查语法。

反射使程序具有可配置和可扩展性：

## 可配置性

我们可以把上面的代码封装一下，并将DB.MySql.MySqlHelper写到配置文件App.config文件中

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759817655318-5e3b9954-efa7-4417-8c1c-fe83754b227c.png)

```csharp
public class SimpleFactory
{
    private static string IDBHelperConfig = ConfigurationManager.AppSettings["IDBHelperConfig"];
    private static string DllName = IDBHelperConfig.Split(',')[1];
    private static string TypeName = IDBHelperConfig.Split(',')[0];
    public static IDBHelper CreateInstance()
    {
        Assembly assembly = Assembly.Load(DllName);
        Type type = assembly.GetType(TypeName);
        object oDBHelper = Activator.CreateInstance(type);
        IDBHelper iDBHelper = oDBHelper as IDBHelper;
        return iDBHelper;
    }
}
```

这串代码就可以读取配置文件中的IDBHelperConfig，获取它的值。其中，要使用ConfigurationManager，需要安装System.Configuration.ConfigurationManager的包。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759805896051-d6892d93-aae9-4a16-aab2-adef8f5be651.png)

我们只需要在编译后的debug文件中，找到Reflection.dll.config文件，修改其中的代码，然后直接运行.exe文件。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850578360-abcf846f-21d6-4bcc-864f-7ae81c99ddb7.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850610053-70c42fae-2e96-4496-94b5-73532310c44e.png)

可以看到，输出结果发生了变化。

## 可扩展性

我们在项目中新建一个类库：DB.Oracle，其中的方法名和上面的类库类似，然后编译。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850647343-da4c9400-8d04-4158-9604-5d9290759171.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850728718-aaf6e530-c63f-4c89-a09b-7b6cc2c3e171.png)

我们只需要将DB.Oracle里dubug里的.dll文件复制到Reflection的dubug里，修改配置项，运行.exe文件：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759850830301-7c0adcf3-1f6c-4657-8fd4-fcb50d5a3004.png)

便可以得到Oracle的结果。所以反射的动态加载和动态创建对象，以及配置文件结合，可以使项目在管理上更加方便。

## 重载的反射

```csharp
public ReflectionTest()
{
    Console.WriteLine("这里是{0}无参数构造函数", this.GetType());
}

public ReflectionTest(string name)
{
    Console.WriteLine("这里是{0} 有参数构造函数", this.GetType());
}

public ReflectionTest(int id)
{
    Console.WriteLine("这里是{0} 有参数构造函数", this.GetType());
}
```

新建一个类：ReflectionTest.cs，同样的方法名不同的参数，通过反射也可以准确的调用。

```csharp
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.ReflectionTest");
foreach (ConstructorInfo ctor in type.GetConstructors())
{
    Console.WriteLine(ctor.Name);
    foreach (var parameter in ctor.GetParameters())
    {
        Console.WriteLine(parameter.ParameterType);
    }
}
object oTest1 = Activator.CreateInstance(type);
object oTest2 = Activator.CreateInstance(type, new object[] { 123 });
object oTest3 = Activator.CreateInstance(type, new object[] { "你好，世界" });
```

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760018443599-13cacbaa-8555-4803-986b-f42bce9fbe67.png)

中间的循环是获取了所有的参数，可以看到反射可以正确获取所有的参数，并正确调用。

## 反射破坏单例

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760018870798-4f36eb3c-aaba-44fc-a682-32e740976a8f.png)

我们设置一个单例，该类的构造函数是private，正常使用Singleton singletonA = (Singleton)Activator.CreateInstance(type); 是无法访问的，但是CreateInstance还有一个参数：nonPublic。这个参数传new，便可以访问私有方法。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760019016559-d34e9231-d844-4e86-b8b3-5fbc168b7131.png)

```csharp
Singleton singletonA = (Singleton)Activator.CreateInstance(type, true);
Singleton singletonB = (Singleton)Activator.CreateInstance(type, true);
```

​	这两行代码不会报错，且singletonA和singletonB是两个不同的实例，而一般的单例只能有一个实例。因此可以称为破坏了单例。

## 泛型的反射

下面，我们写一个泛型的类，再使用反射去调用。

```csharp
public class GenericClass<T, W, X>
{
    public void Show(T t, W w, X x)
    {
        Console.WriteLine("t.type={0},w.type={1},x.type={2}", t.GetType().Name, w.GetType().Name, x.GetType().Name);
    }
}

public class GenericMethod
{
    public void Show<T, W, X>(T t, W w, X x)
    {
        Console.WriteLine("t.type={0},w.type={1},x.type={2}", t.GetType().Name, w.GetType().Name, x.GetType().Name);
    }
}

public class GenericDouble<T>
{
    public void Show<W, X>(T t, W w, X x)
    {
        Console.WriteLine("t.type={0},w.type={1},x.type={2}", t.GetType().Name, w.GetType().Name, x.GetType().Name);
    }
}
Assembly assembly = Assembly.Load("DB.SqlServer");
Type type = assembly.GetType("DB.SqlServer.GenericClass`3");
//GenericClass<string, int, DateTime> genericClass = new GenericClass<string, int, DateTime>();
//object oGeneric = Activator.CreateInstance(type);
Type typeMake = type.MakeGenericType(new Type[] { typeof(string), typeof(int), typeof(DateTime) });
object oGeneric = Activator.CreateInstance(typeMake);
```

这里面要注意，调用泛型方法是要加上`参数数量，如`3，然后用MakeGenericType来确定方法类型。