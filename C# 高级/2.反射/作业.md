1 建立一个数据库，然后执行下面的数据库脚本，会增加两张表 User Company，大家可以去表里面自己多加入一些数据



2 建立数据库表映射的基类BaseModel，包括 Id属性

  建立两个子类Model：公司和用户，按照表结构来



3 提供两个泛型的数据库访问方法，用 BaseModel约束

一个是用id去查询单个实体，(只有这一个参数)

一个是查询出数据表的全部数据列表查询(没有参数)



提示：用DataReader去访问数据库，将得到的结果通过反射生成实体对象/集合返回；



4 封装一个方法，能控制台输出任意实体的全部属性和属性值；



5 进阶需求：提供泛型的数据库实体插入、实体更新、ID删除数据的数据库访问方法；



6 进阶需求（可选）：欢迎小伙伴儿写个实体自动生成器；



7 进阶需求（可选）：将数据访问层抽象，使用简单工厂+配置文件+反射的方式，来提供对数据访问层的使用



8 进阶需求（可选）：每个实体类的基础增删改查SQL语句是不变的，用泛型缓存试试！



版本：

.net 8.0

数据库使用sql server



```csharp
namespace Model
{
    public class BaseModel
    {
        public int Id { get; set; }
    }
}
namespace Model
{
    public class Company: BaseModel
    {
        
        public string Name { get; set; }
        public DateTime CreateTime { get; set; }
        public int CreatorId { get; set; }
        public int? LastModifierId { get; set; }
        public DateTime? LastModifyTime { get; set; }
    }
}
namespace Model
{
    public class User: BaseModel
    {
        public string Name { get; set; }
        public string Account { get; set; }
        public string Password { get; set; }
        public string Email { get; set; }
        public string Mobile { get; set; }
        public int? CompanyId { get; set; }
        public string CompanyName { get; set; }

        public int State { get; set; }
        public int UserType { get; set; }
        public DateTime? LastLoginTime { get; set; }
        public DateTime CreateTime { get; set; }
        public int CreatorId { get; set; }
        public int? LastModifierId { get; set; }

        public DateTime? LastModifyTime { get; set; }
    }
}
using Model;

namespace IDAL
{
    public interface IBaseDAL
    {
        T FindT<T>(int id) where T : BaseModel;
        List<T> FindAllT<T>() where T : BaseModel;
        bool InsertT<T>(T model) where T : BaseModel;
        bool UpdateT<T>(T model) where T : BaseModel;
        bool DeleteT<T>(int id) where T : BaseModel;

    }
}
using IDAL;
using Microsoft.Data.SqlClient;
using Model;
using System.Configuration;

namespace DAL
{
    public class BaseDAL:IBaseDAL
    {
        public T FindT<T>(int id) where T : BaseModel
        {
            Type type = typeof(T);
            string sql = $"SELECT {string.Join(",",type.GetProperties().Select(p=>$"[{p.Name}]"))} FROM [{type.Name}] WHERE Id=@Id";
            object oBject = Activator.CreateInstance(type);
            using (SqlConnection connection = new SqlConnection(ConfigurationManager.ConnectionStrings["TestDB"].ConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, connection);
                command.Parameters.AddWithValue("@Id", id);
                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                if (reader.Read())
                {
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(oBject, reader[prop.Name]);
                    }
                }
                else
                {
                    oBject = null;
                }
            }
            return (T)oBject;
        }

        public List<T> FindAllT<T>() where T : BaseModel
        {
            Type type = typeof(T);
            string sql = $"SELECT {string.Join(",", type.GetProperties().Select(p => $"[{p.Name}]"))} FROM [{type.Name}]" ;
            using (SqlConnection connection = new SqlConnection(ConfigurationManager.ConnectionStrings["TestDB"].ConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, connection);
                connection.Open();
                SqlDataReader reader = command.ExecuteReader();
                List<T> list = new List<T>();
                while (reader.Read())
                {
                    object oBject = Activator.CreateInstance(type);
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(oBject, reader[prop.Name] is DBNull ? null : reader[prop.Name]);
                    }
                    list.Add((T)oBject);
                }
                return list;
            }
        }

        public bool InsertT<T>(T model) where T : BaseModel
        {
            throw new NotImplementedException();
        }

        public bool UpdateT<T>(T model) where T : BaseModel
        {
            throw new NotImplementedException();
        }

        public bool DeleteT<T>(int id) where T : BaseModel
        {
            Type type = typeof(T);
            string sql = $"DELETE FROM [{type.Name}] WHERE Id=@Id";
            using (SqlConnection connection = new SqlConnection(ConfigurationManager.ConnectionStrings["TestDB"].ConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, connection);
                command.Parameters.AddWithValue("@Id", id);
                connection.Open();
                int result = command.ExecuteNonQuery();
                return result > 0;
            }
        }
    }
}
namespace Work
{
    public static class Framwork
    {
        public static void Show<T>(this T t)
        {

            Type type = t.GetType();
            foreach(var prop in type.GetProperties())
            {
                Console.WriteLine($"{prop.Name}:{prop.GetValue(t)}");
            }

        }
    }
}
```