# 委托定义

委托是C#中的一种类型，用于存储对方法的引用。它允许将方法作为参数传递给其他方法，实现回调，动态调用等操作。在c#中，委托用delegate声明，委托的声明可以放在类里，也可以放在类外，下面是委托简单的声明：

```csharp
public delegate void NoReturnNoPara();
public delegate void NoReturnWithPara(int x, int y);//1 声明委托
```

委托即可以声明在类的内部，也可以声明在类的外部。

委托的本质上其实是个类，继承自System.MulticastDelegate类，但这个类是自定义类，无法自定义类来承，因此无法自定义委托类。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761227132876-856d7598-5c25-4468-862a-32b2c803ac30.png)

# 委托的使用

我们来看下委托具体的使用方式，先声明一个方法，然后通过委托去调用它。

```csharp
public class OtherClass
{
    public int add(int a, int b)
    {
        return a + b;
    }
}

// 委托的声明
public delegate int AddDele1(int a, int b);
public delegate int AddDele2(int a, int b);
public delegate int AddDele3(int a, int b);
public void DelegateUse()
public void DelegateUse()
{
    OtherClass other = new();

    AddDele1 method1 = new AddDele1(other.add); //1 委托的实例化  要求传递一个参数类型 返回值都跟委托一致的方法,
    AddDele2 method2 = other.add; // 2 简化写法 
    AddDele2 method3 = delegate (int a, int b) //匿名方法 
    {
        return a + b;
    };

    int result1 = method1.Invoke(1, 2);
    Console.WriteLine("Method1: " + result1);

    int result2 = method2.Invoke(1, 2);
    Console.WriteLine("Method2: " + result2);

    int result3 = method3(1, 2); // 也可以省略.Invoke
    Console.WriteLine("Method3: " + result3);
}
```

​	这里委托用delegate声明 delegate 返回值 委托名(参数)。在使用委托的时候，像实例化类一样去实例化委托，将被调用的方法当参数传给new AddDele1()，被调用的方法的参数跟返回值要跟委托声明时的返回值跟参数要相等，否则会报错。代码里提供了三种方法去使用委托，这三种达到同样的效果。

在使用是，用委托名.Invoke(参数)来调用委托，.Invoke可以省略，运行后的效果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761312201271-67b77a59-21b5-419c-84c7-42eb87d8fc2d.png)

# 委托的应用

如上个例子所示使用委托跟直接调用方法是一样的，那么为什么要使用委托呢。可以看下下面复杂的例子：

```csharp
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int ClassId { get; set; }
    public int Age { get; set; }

    public void Study()
    {
        Console.WriteLine("学习");
    }

    public void SayHi(string name, PeopleType peopleType)
    {
        Console.WriteLine("公共功能");
        switch (peopleType)
        {
            case PeopleType.Chinese:
                Console.WriteLine($"{name},晚上好~");
                break;
            case PeopleType.American:
                Console.WriteLine($"{name},good evening~");
                break;

            default://遇到不认识的枚举，说明调用有问题，那就不要隐藏，直接异常
                throw new Exception("wrong peopleType");
        }
    }

    public void SayHiChinese(string name)
    {
        //Console.WriteLine("公共功能");

        Console.WriteLine($"{name},晚上好~");
    }

    public void SayHiAmerican(string name)
    {
        //Console.WriteLine("公共功能");

        Console.WriteLine($"{name},good evening~");
    }
}

public enum PeopleType
{
    Chinese = 1,
    American = 2
}
```

​	我们写了这样的类，实现不同国家说晚安的方式。代码中有两种实现方式，方法一使用switch语句，方法二是一个国家一个方法。当我们需要增加一个国家的学生时，需要增加分支：

```csharp
public void SayHi(string name, PeopleType peopleType)
{
    Console.WriteLine("公共功能");
    switch (peopleType)
    {
        case PeopleType.Chinese:
            Console.WriteLine($"{name},晚上好~");
            break;
        case PeopleType.American:
            Console.WriteLine($"{name},good evening~");
            break;

        case PeopleType.Malaysia:
            Console.WriteLine($"{name},*^%*^%^&%^%~");
            break;

        default://遇到不认识的枚举，说明调用有问题，那就不要隐藏，直接异常
            throw new Exception("wrong peopleType");
    }
}

public void SayHiMalaysia(string name)
{
    Console.WriteLine("公共功能");
    Console.WriteLine($"{name},*^%*^%^&%^%~~");
}

public enum PeopleType
{
    Chinese = 1,
    American = 2,
    Malaysia = 3
}
```

​	可以看到，需要再加入国家时，方法一是增加一个case的分支，方法二是增加一个方法。这两种方法有各自的优缺点：

方法一：优点是公共代码可以只写到一个地方，代码量小，一个方法便可搞定，缺点是对这个方法要经常改来改去，容易出错。

方法二：优点是各个处理具有独立性，调整或增加一个不会影响别的方法。缺点是写公共代码麻烦，需要每个地方都写。

那么就可以引入委托将上面的优点都结合起来。从方法一到委托就是实现方法解耦。从方法二到委托就是实现方法重用，既能确保个分支独立性又能减少公共代码量。

```csharp
public void SayHiPerfact(string name, SayHiDelegate method)
{
    Console.WriteLine("公共功能");

    method.Invoke(name);
}
public delegate void SayHiDelegate(string name);
```

​	这里name就是参数，method是一个委托，委托中调的就是SayHiChinese，SayHiAmerican等方法，这样就能结合上面两种方法的优点。

```csharp
SayHiDelegate method = new SayHiDelegate(student.SayHiChinese);
student.SayHiPerfact("张三", method);
```

这就是委托的优点：解耦代码，提高代码复用，提高灵活性等