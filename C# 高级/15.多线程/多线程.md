多线程编程是现代软件开发中的重要组成部分，它能够充分利用多核处理器，提高应用程序的性能和响应性。C#作为.NET开发的主要语言，提供了强大的多线程支持。

# 多线程基础

学习多线程需要先了解一些概念：

**1.进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。创建进程多用于桌面应用，web开发也可以创建但用的不多，可以用System.Diagnostics.Process类来创建和执行相关操作。

**2.线程**是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；一个进程包含多个线程，但一个进程必须有一个线程。

**3.多线程**是一种并发编程的技术，它允许一个程序同时执行多个线程，每个线程都有自己的执行流程，但它们共享同一进程的内存空间。多线程的目的是提高程序的性能和响应性，特别是在多核处理器的计算机上。

**4.****线程池** 是多个线程的集合，通过一定逻辑决定如何为线程分配工作。有任务要执行，它分配池中的一个工作者线程执行任务，并在任务结束后解除分配。

**5.****并发** 是指多个任务在同一时间段内交替进行。并发可以通过多线程实现，但也可以通过异步编程实现。即同时有多个任务，操作系统会控制处理器去随机执行一个任务，然后再随机执行另一个任务，在微观上看处理器一次还是处理一个任务，在宏观上看是几个任务一起进行。

## 同步

同步就是一行一行执行代码，执行完一行后跳转到下一行，如果某一行代码执行时间太长，程序就会卡住，无法进行操作。同步会阻塞到线程完成。

## 异步

异步就是执行某行代码时，可以继续往下执行代码，不会阻塞线程。

# 多线程使用

## 同步和异步

```csharp
private void btnSync_Click(object sender, EventArgs e)
{
    Console.WriteLine($"****************btnSync_Click Start {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");

    // 添加计时器
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();

    for (int i = 0; i < 5; i++)
    {
        string name = string.Format($"btnSync_Click_{i}");
        this.DoSomethingLong(name);
    }

    stopwatch.Stop();
    Console.WriteLine($"同步方法总耗时: {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"****************btnSync_Click   End {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");
}
private void DoSomethingLong(string name)
{
    Console.WriteLine($"****************DoSomethingLong Start  {name}  {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");
    long lResult = 0;
    for (int i = 0; i < 1_000_000_000; i++)
    {
        lResult += i;
    }
    //Thread.Sleep(2000);

    Console.WriteLine($"****************DoSomethingLong   End  {name}  {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")} {lResult}***************");
}
private async void btnAsync_Click(object sender, EventArgs e)
{
    Console.WriteLine($"****************btnAsync_Click Start {Thread.CurrentThread.ManagedThreadId:00} {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}***************");

    // 添加计时器
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();

    // 将每个耗时操作放到线程池，不阻塞 UI，等待全部完成
    var tasks = Enumerable.Range(0, 5)
                          .Select(i => Task.Run(() => DoSomethingLong($"btnAsync_Click_{i}")))
                          .ToArray();

    try
    {
        await Task.WhenAll(tasks);
    }
    catch (Exception ex)
    {
        // 处理子任务异常（Task.WhenAll 会聚合异常）
        Console.WriteLine($"子任务异常: {ex}");
    }

    stopwatch.Stop();
    Console.WriteLine($"异步方法总耗时: {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"****************btnAsync_Click End   {Thread.CurrentThread.ManagedThreadId:00} {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}***************");
}
```

这个程序是winform程序，设置了几个按钮，btnSync_Click和btnAsync_Click就是点击按钮执行的事件。btnSync_Click内是for循环，就是常规的同步代码，btnAsync_Click就是异步代码。每个按钮执行5次，每次会循环十亿次。执行结果如下：

同步代码：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1766760574335-5d8d88c0-146e-4ca2-943f-dae651421895.png)

在执行期间，程序会卡住，点不了其他按钮，只有执行完后才能继续操作程序

同步方法总耗时: 9108ms

异步代码：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1766760594914-d18223f1-94ef-445c-a007-16365035b3db.png)

异步方法总耗时: 1850ms



可以看到异步方法比同步代码要快很多，因为异步代码是5个线程一起运行。如果把线程数改成32，那么运行结果会差距更大：

异步方法总耗时: 3639ms，同步方法总耗时: 58685ms

但线程多的同时cpu占用也高，因此多线程是一种性能换时间的操作。

## 同步和异步的优缺点

​       同步方法会卡界面，异步多线程方法不卡界面，因此异步方法可以改善用户体验。

同步方法慢，只有一个线程计算，异步多线程方法快，因为多个线程并发计算，但线程不能取的很大，因为cpu资源是有限的，并且资源调度会有损耗因此5个线程，但执行时间不是同步方法的1/5。

同步方法有序进行，异步多线程无序。启动无序：线程资源是向操作系统申请的，由操作系统的调度策略决定，所以启动顺序随机，同一个任务同一个线程，执行时间也不确定，CPU分片，因此结束时间也无序，可以看上面的截图，启动是0,1,2,3,4，但结束是1,2,0,4,3。线程的顺序是随机的，不好预测的，无法控制顺序。