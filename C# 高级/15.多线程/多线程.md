多线程编程是现代软件开发中的重要组成部分，它能够充分利用多核处理器，提高应用程序的性能和响应性。C#作为.NET开发的主要语言，提供了强大的多线程支持。

# 多线程基础

学习多线程需要先了解一些概念：

**1.进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。创建进程多用于桌面应用，web开发也可以创建但用的不多，可以用System.Diagnostics.Process类来创建和执行相关操作。

**2.线程**是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；一个进程包含多个线程，但一个进程必须有一个线程。

**3.多线程**是一种并发编程的技术，它允许一个程序同时执行多个线程，每个线程都有自己的执行流程，但它们共享同一进程的内存空间。多线程的目的是提高程序的性能和响应性，特别是在多核处理器的计算机上。

**4.****线程池** 是多个线程的集合，通过一定逻辑决定如何为线程分配工作。有任务要执行，它分配池中的一个工作者线程执行任务，并在任务结束后解除分配。

**5.****并发** 是指多个任务在同一时间段内交替进行。并发可以通过多线程实现，但也可以通过异步编程实现。即同时有多个任务，操作系统会控制处理器去随机执行一个任务，然后再随机执行另一个任务，在微观上看处理器一次还是处理一个任务，在宏观上看是几个任务一起进行。

## 同步

同步就是一行一行执行代码，执行完一行后跳转到下一行，如果某一行代码执行时间太长，程序就会卡住，无法进行操作。同步会阻塞到线程完成。

## 异步

异步就是执行某行代码时，可以继续往下执行代码，不会阻塞线程。

# 多线程使用

## 同步和异步

```csharp
private void btnSync_Click(object sender, EventArgs e)
{
    Console.WriteLine($"****************btnSync_Click Start {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");

    // 添加计时器
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();

    for (int i = 0; i < 5; i++)
    {
        string name = string.Format($"btnSync_Click_{i}");
        this.DoSomethingLong(name);
    }

    stopwatch.Stop();
    Console.WriteLine($"同步方法总耗时: {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"****************btnSync_Click   End {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");
}
private void DoSomethingLong(string name)
{
    Console.WriteLine($"****************DoSomethingLong Start  {name}  {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")}***************");
    long lResult = 0;
    for (int i = 0; i < 1_000_000_000; i++)
    {
        lResult += i;
    }
    //Thread.Sleep(2000);

    Console.WriteLine($"****************DoSomethingLong   End  {name}  {Thread.CurrentThread.ManagedThreadId.ToString("00")} {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")} {lResult}***************");
}
private async void btnAsync_Click(object sender, EventArgs e)
{
    Console.WriteLine($"****************btnAsync_Click Start {Thread.CurrentThread.ManagedThreadId:00} {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}***************");

    // 添加计时器
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();

    // 将每个耗时操作放到线程池，不阻塞 UI，等待全部完成
    var tasks = Enumerable.Range(0, 5)
                          .Select(i => Task.Run(() => DoSomethingLong($"btnAsync_Click_{i}")))
                          .ToArray();

    try
    {
        await Task.WhenAll(tasks);
    }
    catch (Exception ex)
    {
        // 处理子任务异常（Task.WhenAll 会聚合异常）
        Console.WriteLine($"子任务异常: {ex}");
    }

    stopwatch.Stop();
    Console.WriteLine($"异步方法总耗时: {stopwatch.ElapsedMilliseconds}ms");
    Console.WriteLine($"****************btnAsync_Click End   {Thread.CurrentThread.ManagedThreadId:00} {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}***************");
}
```

这个程序是winform程序，设置了几个按钮，btnSync_Click和btnAsync_Click就是点击按钮执行的事件。btnSync_Click内是for循环，就是常规的同步代码，btnAsync_Click就是异步代码。每个按钮执行5次，每次会循环十亿次。执行结果如下：

同步代码：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1766760574335-5d8d88c0-146e-4ca2-943f-dae651421895.png)

在执行期间，程序会卡住，点不了其他按钮，只有执行完后才能继续操作程序

同步方法总耗时: 9108ms

异步代码：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1766760594914-d18223f1-94ef-445c-a007-16365035b3db.png)

异步方法总耗时: 1850ms



可以看到异步方法比同步代码要快很多，因为异步代码是5个线程一起运行。如果把线程数改成32，那么运行结果会差距更大：

异步方法总耗时: 3639ms，同步方法总耗时: 58685ms

但线程多的同时cpu占用也高，因此多线程是一种性能换时间的操作。

## 同步和异步的优缺点

​       同步方法会卡界面，异步多线程方法不卡界面，因此异步方法可以改善用户体验。

同步方法慢，只有一个线程计算，异步多线程方法快，因为多个线程并发计算，但线程不能取的很大，因为cpu资源是有限的，并且资源调度会有损耗因此5个线程，但执行时间不是同步方法的1/5。

同步方法有序进行，异步多线程无序。启动无序：线程资源是向操作系统申请的，由操作系统的调度策略决定，所以启动顺序随机，同一个任务同一个线程，执行时间也不确定，CPU分片，因此结束时间也无序，可以看上面的截图，启动是0,1,2,3,4，但结束是1,2,0,4,3。线程的顺序是随机的，不好预测的，无法控制顺序。

## 任务等待

虽然异步线程无法控制顺序，但可以控制同步的顺序。

方法一：可以通过回调的方法，将线程执行成功的后操作的代码放到回调中去执行。

```csharp
Action<string> action = this.DoSomethingLong;
var t = Task.Run(() => action("btnAsyncAdvanced_Click"));
t.ContinueWith(t2 =>
{
    if (t2.IsCompletedSuccessfully)
    {
        Console.WriteLine($"btnAsyncAdvanced_Click 计算成功（回调）. {Thread.CurrentThread.ManagedThreadId:00}");
    }
    else if (t2.IsFaulted)
    {
        Console.WriteLine($"子任务异常: {t2.Exception}");
    }
}, TaskScheduler.FromCurrentSynchronizationContext());
```

方法二：通过IsCompleted进行轮询等待，在线程运行期间，t.IsCompleted为false，会重复运行循环代码，当线程完成后，就会跳过循环代码，往下运行。

```csharp
var pollingTask = Task.Run(async () =>
{
    int i = 0;
    while (!t.IsCompleted)
    {
        if (i < 9) Console.WriteLine($"完成{++i * 10}%....");
        else Console.WriteLine($"完成99.999999%....");
        await Task.Delay(200); // 不阻塞 UI 线程
    }
    Console.WriteLine("已完成");
});
```

方法三：使用await获取返回值

```csharp
Func<int> func = () =>
{
    Thread.Sleep(2000);
    return DateTime.Now.Hour;
};
var task = Task.Run(func);
task.ContinueWith(t2 =>
{
    if (t2.IsCompletedSuccessfully) Console.WriteLine($"回调（UI）结果: {t2.Result}");
    else Console.WriteLine($"子任务异常: {t2.Exception}");
}, TaskScheduler.FromCurrentSynchronizationContext());
int result = await task;
```

# Thread实现多线程

C#中通过使用 Thread 类实现多线程编程。Thread 类位于 System.Threading 命名空间中，该类主要用于创建并控制线程、设置线程优先级并获取其状态。

Thread基本写法如下：

```csharp
ParameterizedThreadStart method = o => this.DoSomethingLong("btnThread_Click");
Thread thread = new Thread(method);
thread.Start("123");
```

常用的方法和属性：

Thread.Sleep(200) ：当前线程休息200ms

thread.Join(1000); 最多等待1000ms

thread.Start();//开启线程，执行委托的内容

thread.Priority 将线程的优先级，设置优先级但不代表绝对的优先完成



```csharp
Func<int> func = () =>
    {
        Thread.Sleep(5000);
        return DateTime.Now.Year;
    };
Func<int> funcThread = this.ThreadWithReturn(func);//非阻塞
Console.WriteLine("do something else/////");
Console.WriteLine("do something else/////");
Console.WriteLine("do something else/////");
Console.WriteLine("do something else/////");
Console.WriteLine("do something else/////");

int iResult = funcThread.Invoke();//阻塞

private Func<T> ThreadWithReturn<T>(Func<T> func)
{
    T t = default(T);
    ThreadStart threadStart = new ThreadStart(() =>
    {
        t = func.Invoke();
    });
    Thread thread = new Thread(threadStart);
    thread.Start();

    return new Func<T>(() =>
    {
        thread.Join();
        //thread.ThreadState
        return t;
    });
}
```

这段代码展示了异步获取返回值的功能。Func<int> funcThread = this.ThreadWithReturn(func);代码来执行异步方法，执行期间代码可以做其他事，当程序需要用异步方法的返回值时，再通过阻塞去获取返回值。

# 线程池

为了避免频繁创建和销毁线程的巨大开销，.NET 提供了一个**线程池**。它是一个由 CLR (公共语言运行时) 管理的后台工作者线程集合。

线程池就是线程在排队等待任务，任务完成后线程不会销毁，会继续进行排队

  ThreadPool.SetMaxThreads(8, 8);//设置的最大值，必须大于CPU核数，否则设置无效

  ThreadPool.SetMinThreads(2, 2);

线程池设置最大线程数和最小线程数，这个设置是全局的，所有异步都会生效。

```csharp
ThreadPool.QueueUserWorkItem(o => this.DoSomethingLong("btnThreadPool_Click1"));
```

这个就是给线程池派一个任务。

```csharp
ManualResetEvent mre = new ManualResetEvent(false);
//false---关闭---Set打开---true---WaitOne就能通过
//true---打开--ReSet关闭---false--WaitOne就只能等待
ThreadPool.QueueUserWorkItem(o =>
{
    this.DoSomethingLong("btnThreadPool_Click1");
    mre.Set();
});
Console.WriteLine("Do Something else...");
Console.WriteLine("Do Something else...");
Console.WriteLine("Do Something else...");

mre.WaitOne();
Console.WriteLine("任务已经完成了。。。");
```

上面的代码是线程池的等待功能。

# Task

Task是基于线程池，然后提供了丰富的API，可以应对更多的场景。Task有Task类和TaskFactory类。



```csharp
{
    Task task = new Task(() => this.DoSomethingLong("btnTask_Click_1"));
    task.Start();
}
{
    Task task = Task.Run(() => this.DoSomethingLong("btnTask_Click_2"));
}
{
    TaskFactory taskFactory = Task.Factory;
    Task task = taskFactory.StartNew(() => this.DoSomethingLong("btnTask_Click_3"));
}
TaskFactory taskFactory = new TaskFactory();
List<Task> taskList = new List<Task>();
taskList.Add(taskFactory.StartNew(() => this.Coding("冰封的心", "Portal")));
taskList.Add(taskFactory.StartNew(() => this.Coding("随心随缘", "  DBA ")));
taskList.Add(taskFactory.StartNew(() => this.Coding("心如迷醉", "Client")));
taskList.Add(taskFactory.StartNew(() => this.Coding(" 千年虫", "BackService")));
taskList.Add(taskFactory.StartNew(() => this.Coding("简单生活", "Wechat")));

//谁第一个完成，获取一个红包奖励
taskFactory.ContinueWhenAny(taskList.ToArray(), t => Console.WriteLine($"XXX开发完成，获取个红包奖励{Thread.CurrentThread.ManagedThreadId.ToString("00")}"));
//实战作业完成后，一起庆祝一下
taskList.Add(taskFactory.ContinueWhenAll(taskList.ToArray(), rArray => Console.WriteLine($"开发都完成，一起庆祝一下{Thread.CurrentThread.ManagedThreadId.ToString("00")}")));
//ContinueWhenAny  ContinueWhenAll 非阻塞式的回调；而且使用的线程可能是新线程，也可能是刚完成任务的线程，唯一不可能是主线程


//阻塞当前线程，等着任意一个任务完成
Task.WaitAny(taskList.ToArray());//也可以限时等待
Console.WriteLine("Eleven准备环境开始部署");
//需要能够等待全部线程完成任务再继续  阻塞当前线程，等着全部任务完成
Task.WaitAll(taskList.ToArray());
Console.WriteLine("5个模块全部完成后，Eleven集中点评");
```

这段代码是创建了5个线程并发执行，当任意一个线程完成后，执行程序，当所有线程完成后，执行另一段程序，taskFactory的ContinueWhenAny  ContinueWhenAll是非阻塞式的，Task.WaitAny Task.WaitAll是阻塞了当前进程。