# 什么是特性

C# 中的特性（Attributes）是一种用于在声明中添加元数据的机制，本质也是一个类。它们允许程序员向类型、成员（如类、方法、属性等）添加信息，程序可以在运行时通过反射获取到这些信息。特性以 '`[ ]` '括起来，放置在相应的声明之前。如[Serializable]，[Description]等

特性有预定义特性和自定义特性

# 预定义特性

预定义特性是会影响到编译器的，是自定义特性无法做到的功能，预定义特性分为三种：AttributeUsage，Conditional，Obsolete。

## AttributeUsage

预定义特性 AttributeUsage 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。

如：

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
```

**第一个参数ValidOn**：规定特性可被放置的元素。它是枚举器 AttributeTargets 的值的组合。默认值是 AttributeTargets.All，如例子中声明的特性可以放在类或者方法，默认的AttributeTargets.All是放在所有的成员。

**第二个参数AllowMultiple：**规定放在成员上时，同个成员是否可以重复放置，这个参数是个布尔值，默认是false。

**第三个参数Inherited：**若放置在属性上时，该参数规定这个属性是否能被子类继承，默认为true，表示可以继承。

## Conditional

这个预定义特性标记的是方法，被标记的方法会在特殊情况下才能被调用。

如：

```csharp
[Conditional("DEBUG")]
```

在调佣该方法的类的开头中，需要使用#define DEBUG，被标记的方法才能被调用。

## Obsolete

这个预定义特性通常来标记不太使用的实体，被标记的实体如果被调用，那么会弹出警告或者报错，如：

```csharp
[Obsolete("此方法无法使用", true)]
```

这个特性标记了方法，那么调用该方法时，直接会出现报错，并显示此方法无法使用。

第二个参数为true，表示抛出报错，否则是弹出警告，但方法可以继续使用。

# 自定义特性

声明一个自定义特性时，其实就是声明一个类，这个类继承了Attribute。

```csharp
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)]
public class CustomAttribute : Attribute
{
    public CustomAttribute()
    {
        Console.WriteLine($"{this.GetType().Name} 无参数构造函数执行");
    }
    public CustomAttribute(int id)
    {
        Console.WriteLine($"{this.GetType().Name} int参数构造函数执行");
        this._Id = id;
    }
    public CustomAttribute(string name)
    {
        Console.WriteLine($"{this.GetType().Name} string参数构造函数执行");
        this._Name = name;
    }

    private int _Id = 0;
    private string _Name = null;

    public string Remark;
    public string Description { get; set; }

    public void Show()
    {
        Console.WriteLine($"{this._Id}_{this._Name}_{this.Remark} _ {this.Description}");
    }
}
[Custom]
[Custom(0)]
[Custom(0, Remark = "123")]
[Custom(0, Remark = "123", Description = "456")]
public class Student
{
    [Custom]
    public int Id { get; set; }
    public string Name { get; set; }
    [Custom]
    public void Study()
    {
        Console.WriteLine($"我是{this.Name}");
    }

    [return: Custom, Custom,Custom(), Custom(0, Remark = "123", Description = "456")]
    [Custom(0)]
    [Custom(0, Remark = "123")]
    [Custom(0, Remark = "123", Description = "456")]
    public string Answer([Custom]string name)
    {
        return $"This is {name}";
    }
}
```

CustomAttribute.cs是自定义的一个特性类前面的AttributeUsage表示该特性可以放在任何成员中，可以重复放，属性可以继承，Student.cs类则是各种使用。这些使用都是正确的，可以试试实例化Student.cs运行后会发生什么：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761140222181-2445ff59-55ee-4502-b39d-5c95053a8a25.png)

可以看到程序仍然运行了Console.WriteLine($"我是{this.Name}");语句，无法判断特性成不成功，感觉特性在这里没有用，那么怎么才能访问特性呢？当然是反射。

## 反射调用特性

```csharp
public class InvokeCenter
{
    public static void ManagerStudent<T>(T student) where T : Student
    {
        Console.WriteLine($"{student.Id}_{student.Name}");
        student.Study();
        student.Answer("答案");

        Type type = student.GetType();
        if (type.IsDefined(typeof(CustomAttribute), true))
        {
            object[] oAttributeArray = type.GetCustomAttributes(typeof(CustomAttribute), true);
            foreach (CustomAttribute attr in oAttributeArray)
            {
                attr.Show();
            }

            foreach(var prop in type.GetProperties())
            {
                if(prop.IsDefined(typeof(CustomAttribute), true))
                {
                    object[] pAttributeArray = prop.GetCustomAttributes(typeof(CustomAttribute), true);
                    foreach (CustomAttribute attr in pAttributeArray)
                    {
                        attr.Show();
                    }
                }
            }
        }
    }

}
```

我们使用反射和泛型重新写这么个代码，运行后的结果如图所示：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761141813297-92493a1c-76c2-419c-b879-6f1697de7759.png)