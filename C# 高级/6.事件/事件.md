# 事件是什么

事件和委托其实是息息相关的，事件其实是对委托的一个约束，事件在委托的基础上提供了更安全的封装机制。

# 事件的使用

事件使用event来声明：

```csharp
public event EventHandler IncreaseHandler;

public class XEventArgs : EventArgs
{
    public int OldPrice { get; set; }
    public int NewPrice { get; set; }
}

public class Lesson
{
    public int Id { get; set; }
    public string Name { get; set; }

    private int _price = int.MaxValue;
    public int Price
    {
        get
        {
            return this._price;
        }
        set
        {
            if (value < this._price)
            {
                this.IncreaseHandler?.Invoke(this,
                    new XEventArgs()
                    {
                        OldPrice = this._price,
                        NewPrice = value
                    });
                this._price = value;
            }
        }
    }
```

这里写了个事件的声明，又写了事件的实现。EventHandler是委托类，IncreaseHandler便是事件的名称。Lesson类中为Price值赋值时写了IncreaseHandler的具体的使用。

```csharp
public static void Show()
{
    Lesson lesson = new Lesson()
    {
        Id = 123,
        Name = "c#进阶",
        Price = 4699
    };
    //订阅：把订户和发布者的事件关联起来
    lesson.IncreaseHandler += new Student().Buy;
    lesson.IncreaseHandler += new Tencent().Popularize;
    lesson.Price = 3999;
}


/// <summary>
/// 订户：关注事件，事件发生后，自己做出对应的动作
/// </summary>
public class Student
{
    public void Buy(object sender, EventArgs e)
    {
        Lesson lesson = (Lesson)sender;
        Console.WriteLine($"This is {lesson.Name} Lesson");

        XEventArgs args = (XEventArgs)e;
        Console.WriteLine($"之前价格{args.OldPrice}");
        Console.WriteLine($"现在价格{args.NewPrice}");
        Console.WriteLine("果断买了！！！");
    }
}
public class Tencent
{
    public void Popularize(object sender, EventArgs e)
    {
        Lesson lesson = (Lesson)sender;
        Console.WriteLine($"This is {lesson.Name} Lesson");

        XEventArgs args = (XEventArgs)e;
        Console.WriteLine($"之前价格{args.OldPrice}");
        Console.WriteLine($"现在价格{args.NewPrice}");
        Console.WriteLine("广大用户请留意！！！");
    }
}
```

运行Show()方法后，结果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761835611988-b0590f17-248a-4ff5-be43-203176ddb2b7.png)

event在这里起到什么作用呢，我们把event去掉，变成public EventHandler IncreaseHandler; 得到的结果是一样的，那么event有什么用？

# 事件的作用

我们可以看下这个编译器的报错：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1761835748854-1e8a18ca-ce84-41c3-a3e6-59cfc989c530.png)

这里显示IncreaseHandler只能出现在 += 或 -= 的左边，使用IncreaseHandler = 方法名 语句是错误的。这就是事件的作用，事件相当于是对一部分委托进行封装，使用事件时会运行封装内的代码，在这基础上再运行 += 右边的代码，委托不一样，委托可以通过=直接赋值，缺少了封装性。这也是事件相比委托的优点。