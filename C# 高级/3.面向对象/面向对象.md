# 面向对象是什么

面向对象主要是一种思维方式，这种方式更适合在项目中使用。

举个例子：用手机玩游戏

常规的面向过程的步骤就是打开手机，手机联网，启动游戏，开始游戏，Play，结束游戏。正常情况下这个步骤没问题，但有很多异常情况要考虑：如不同游戏玩法不一样，手机配置有区别，手机没电了，没网。。。都要用额外的步骤去处理。在开发中，面向过程就要求开发者把所有情况都写出来，且复用性比较弱。

面向对象不一样，面向对象是把上述几个步骤封装起来，如下面代码所示，

```csharp
Player player = new Player()
{
    Id = 123,
    Name = "张三"
};
iPhone phone = new iPhone();
player.PlayiPhone(phone);
```

这段代码就声明了玩家，手机型号，手机玩游戏这个动作，玩游戏的具体实现，就放在PlayiPhone里

# 三要素

## 封装

### 介绍

你不需要了解这个方法里面写了什么代码，你只需要了解这个方法是做什么的，传什么参数实现什么效果。其实就是把可以重复使用的代码，用方法装载起来，传入参数，返回参数；让代码更加容易维护，这样就不必每次访问这个属性的时候，还需要再写一次重复的代码

根据网游戏的需求，可以封装成下面的几个类：

```csharp
public class Player
{
    public int Id { get; set; } // 属性
    public string Name { get; set; }

    public void PlayiPhone(iPhone phone) // 方法
    {
        phone.Open();

        phone.PlayGame();
    }
}
```

这是玩家的基础信息，和玩家玩游戏的封装，对于不同的玩家，他们会有名字，性别，身份证号等差别，这就有了属性。但玩家都会玩游戏，就有了方法，PlayiPhone使用了iPhone类，这又是一个手机类。

```csharp
public class iPhone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Branch { get; set; }

    public void Call()
    {
        Console.WriteLine($"Use {this.GetType().Name} Call");
    }

    public void Open()
    {
        Console.WriteLine($"Use {this.GetType().Name} Open 1");
    }

    public void Close()
    {
        Console.WriteLine($"Use {this.GetType().Name} Close 2");
    }

    public void PlayGame()
    {
        Game game = new Game();
        game.Start();
        game.Fighting();
        game.Over();
    }
}
```

这是一个iPhone类，包含了手机的基本信息，名字、品牌等，又列举了打电话，开机，玩游戏等操作，而玩游戏中，不同的游戏有不同的处理方式，又要写个Game类。

```csharp
public class Game
{
    public int Id { get; set; }
    public string Name { get; set; }
    public void Start()
    {
        Console.WriteLine($"{this.GetType().Name} Start");
    }

    public void Fighting()
    {
        Console.WriteLine($"{this.GetType().Name} Fighting");
    }

    public void Over()
    {
        Console.WriteLine($"{this.GetType().Name} Over");
    }
}
```

这是个游戏类，也包含游戏名称等属性，游戏的操作等方法。

上面就是对这几个的简单封装，主程序里只需要对不同玩家实例化类，而不同的玩家，不同的手机有什么不一样，这些就放在类里处理。

这里主要涉及到了几个关键字：public,protected等，这是修饰符

### 访问修饰符

| 访问修饰符    | 当前类 | 派生类（同程序集） | 派生类（不同程序集） | 同程序集的其他类 | 不同程序集的其他类 | 主要用途         |
| ------------- | ------ | ------------------ | -------------------- | ---------------- | ------------------ | ---------------- |
| **private**   | ✅      | ❌                  | ❌                    | ❌                | ❌                  | 封装内部实现细节 |
| **protected** | ✅      | ✅                  | ✅                    | ❌                | ❌                  | 家族继承专用     |
| **internal**  | ✅      | ✅                  | ❌                    | ✅                | ❌                  | 程序集内部共享   |
| **public**    | ✅      | ✅                  | ✅                    | ✅                | ✅                  | 完全公开访问     |

## 继承

### 介绍

继承，就是子类可以继承父类的成员，并在此基础上增加和修改父类成员。这个特性可以不用再写一遍父类的属性，就可以直接调用父类的属性(相当于父类可继承的属性就是你的属性)，一段代码多次使用，提高代码的复用性并减少代码的冗余。

以手机为例，手机有不同的品牌，不同型号。这些手机有有着相同点，因此可以将相同点拿出来放在一个类，具体的手机类继承这个共同类。将iPhone.cs的部分属性和方法放到BasePhone中。

```csharp
public abstract class BasePhone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Branch { get; set; }

    public abstract void System();
    
    public void Call()
    {
        Console.WriteLine($"Use {this.GetType().Name} Call");
    }

    public void Open()
    {
        Console.WriteLine($"Use {this.GetType().Name} Open 1");
    }

    public void Close()
    {
        Console.WriteLine($"Use {this.GetType().Name} Close 2");
    }
}
public interface IExtend
{
    void PlayGame();

    //void Play(int i);

    //int Tag { get; set; }//属性可以
    ////string Remark=null;//字段不行
    ////class Test {}//不行
    ////delegate void NoAction();//不行
    //event Action DoNothingHandler;//事件可以
    //int this[int i]
    //{
    //    get;
    //}//索引器可以

}
```

上面的代码写了抽象类BasePhone和一个接口IExtend。

### 抽象类

抽象类可以理解为对类的进一步拓展。它除了可以包含抽象方法（没有实现的方法）外，还可以包含普通的方法和属性。抽象类不能被实例化，只能被继承。也就是说，其他类可以通过继承抽象类来获得其所有的属性和方法，并可以选择性地覆盖或实现其中的某些方法。

abstract class BasePhone便是抽象类的声明，只能在抽象类中添加抽象方法public abstract void System();该方法不需要具体的实现，需要在继承后重载(override)

抽象类不能被实例化，只能通过继承去访问，因此使用BasePhone base = new BasePhone()是错误的，编译器会直接报错。

### 接口

接口可以被理解为对方法的集合。接口中只能包含没有实现的方法（也就是抽象方法），并且不能包含任何实现。接口的成员不能有任何访问修饰符，也就是说，接口中的所有方法都是公开的（public）。接口可以多继承，也就是说，一个类可以实现多个接口。

在接口中不能有字段，不能有具体实现的方法，只能有属性、事件、索引，接口也不能被实例化。

当类继承了接口时，必须实现该接口所有的成员函数，void PlayGame(); 否则编译器会报错。



iPhone只需要留下PlayGame()方法，: BasePhone实现了继承的效果，访问iPhone类时也能访问BasePhone的属性和方法。

```csharp
public class iPhone : BasePhone, IExtend
{

    public override void System()
    {
        Console.WriteLine($"{this.GetType().Name} System is IOS");
    }
    
    public void PlayGame()
    {
        Game game = new Game();
        game.Start();
        game.Fighting();
        game.Over();
    }
}
```

我们也可以再加一个手机类：

```csharp
public class Vivo : BasePhone, IExtend
{
    public override void System()
    {
        Console.WriteLine($"{this.GetType().Name} System is Android");
    }
    
    public void PlayGame()
    {
        Game game = new Game();
        game.Start();
        game.Fighting();
        game.Over();
    }
}
```

这个类的效果和iPhone是相同的。

## 多态

### 介绍

多态，就是对于同一种事物，有不同的体现。如上面的手机，虽然有共同点，不同的品牌也有自己特殊的点，因此可以用多态进行区分。

多态主要的内容有重载和重写

### 重载

重载无需声明修饰符，同一个类中定义多个同名的方法,但是方法传入的参数列表不同(即参数的类型、个数或顺序不同)。

### 重写

重写需要修饰符override声明，重写是方法名和方法参数相同，一般是子类重写父类的方法，被重写的方法需要用修饰符abstract抽象或virtual虚方法修饰。

可以看下这组类

```csharp
public abstract class ParentClass
{

    public ParentClass(int id)
    { }

    /// <summary>
    /// CommonMethod
    /// </summary>
    public void CommonMethod()
    {
        Console.WriteLine("ParentClass CommonMethod");
    }

    /// <summary>
    /// virtual  虚方法  必须包含实现 但是可以被重载
    /// </summary>
    public virtual void VirtualMethod()
    {
        Console.WriteLine("ParentClass VirtualMethod");
    }

    public virtual void VirtualMethod(string name)
    {
        Console.WriteLine("ParentClass VirtualMethod");
    }

    public abstract void AbstractMethod();
}

public class ChildClass : ParentClass
{
    /// <summary>
    /// 实例化子类的时候，是先完成父类的实例化的
    /// </summary>
    public ChildClass()
        : base(3)//调用父类的构造函数
    {
    }

    /// <summary>
    /// new 隐藏
    /// </summary>
    public new void CommonMethod()
    {
        Console.WriteLine("ChildClass CommonMethod");
        // base this
    }

    /// <summary>
    /// virtual 可以被覆写
    /// </summary>
    /// <param name="obj"></param>
    /// <returns></returns>
    public override void VirtualMethod()
    {
        Console.WriteLine("ChildClass VirtualMethod");
        base.VirtualMethod();//base表示调用直接父类的这个方法
    }

    /// <summary>
    /// 抽象方法必须覆写
    /// </summary>
    public sealed override void AbstractMethod()
    {
        Console.WriteLine("ChildClass AbstractMethod");
    }
}
```

这里写了个抽象类ParentClass，里面包含了虚方法virtual和抽象方法abstract。并写了个子类去继承。

```csharp
public static void Test()
{
    Console.WriteLine("*******************************************");
    Console.WriteLine("*******************************************");
    Console.WriteLine("*******************************************");

    ParentClass instance = new ChildClass();

    Console.WriteLine("下面是instance.CommonMethod()");
    instance.CommonMethod();//子类new隐藏  父类方法   普通方法由编译时决定--提高效率

    Console.WriteLine("下面是instance.VirtualMethod()");
    instance.VirtualMethod();//子类覆写的虚方法  子类方法  虚方法由运行时决定的--多态灵活
    Console.WriteLine("下面是instance.AbstractMethod()");
    instance.AbstractMethod();//子类实现的抽象方法  子类方法  抽象方法由运行时决定的--多态灵活

    Console.WriteLine("*******************************************");
    Console.WriteLine("*******************************************");
    Console.WriteLine("*******************************************");
}
```

上面的ParentClass instance = new ChildClass(); 就是多态的一种应用，运行后，结果是这样的：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1760868076242-7a6b69f5-0f47-477c-bf7d-6876cc3e6116.png)

这里也用到了几个修饰符：

### **virtual**

虚方法，允许被子类重写，但提供默认实现，被virtual修饰的方法必须要有具体实现，也可以被重写。

### **abstract** 

抽象，被abstract修饰的方法没有具体实现，但子类必须重写所有的抽象方法。

### **sealed** 

密封，被修饰的方法无法被重写，被修饰的类也无法被继承。
