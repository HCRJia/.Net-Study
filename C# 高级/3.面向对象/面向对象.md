# 面向对象是什么

面向对象主要是一种思维方式，这种方式更适合在项目中使用。

举个例子：用手机玩游戏

常规的面向过程的步骤就是打开手机，手机联网，启动游戏，开始游戏，Play，结束游戏。正常情况下这个步骤没问题，但有很多异常情况要考虑：如不同游戏玩法不一样，手机配置有区别，手机没电了，没网。。。都要用额外的步骤去处理。在开发中，面向过程就要求开发者把所有情况都写出来，且复用性比较弱。

面向对象不一样，面向对象是把上述几个步骤封装起来，如下面代码所示，

```csharp
Player player = new Player()
{
    Id = 123,
    Name = "张三"
};
iPhone phone = new iPhone();
player.PlayiPhone(phone);
```

这段代码就声明了玩家，手机型号，手机玩游戏这个动作，玩游戏的具体实现，就放在PlayiPhone里

# 三要素

## 封装

### 介绍

你不需要了解这个方法里面写了什么代码，你只需要了解这个方法是做什么的，传什么参数实现什么效果。其实就是把可以重复使用的代码，用方法装载起来，传入参数，返回参数；让代码更加容易维护，这样就不必每次访问这个属性的时候，还需要再写一次重复的代码

根据网游戏的需求，可以封装成下面的几个类：

```csharp
public class Player
{
    public int Id { get; set; } // 属性
    public string Name { get; set; }

    public void PlayiPhone(iPhone phone) // 方法
    {
        phone.Open();

        phone.PlayGame();
    }
}
```

这是玩家的基础信息，和玩家玩游戏的封装，对于不同的玩家，他们会有名字，性别，身份证号等差别，这就有了属性。但玩家都会玩游戏，就有了方法，PlayiPhone使用了iPhone类，这又是一个手机类。

```csharp
public class iPhone
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Branch { get; set; }

    public void Call()
    {
        Console.WriteLine($"Use {this.GetType().Name} Call");
    }

    public void Open()
    {
        Console.WriteLine($"Use {this.GetType().Name} Open 1");
    }

    public void Close()
    {
        Console.WriteLine($"Use {this.GetType().Name} Close 2");
    }

    public void PlayGame()
    {
        Game game = new Game();
        game.Start();
        game.Fighting();
        game.Over();
    }
}
```

这是一个iPhone类，包含了手机的基本信息，名字、品牌等，又列举了打电话，开机，玩游戏等操作，而玩游戏中，不同的游戏有不同的处理方式，又要写个Game类。

```csharp
public class Game
{
    public int Id { get; set; }
    public string Name { get; set; }
    public void Start()
    {
        Console.WriteLine($"{this.GetType().Name} Start");
    }

    public void Fighting()
    {
        Console.WriteLine($"{this.GetType().Name} Fighting");
    }

    public void Over()
    {
        Console.WriteLine($"{this.GetType().Name} Over");
    }
}
```

这是个游戏类，也包含游戏名称等属性，游戏的操作等方法。

上面就是对这几个的简单封装，主程序里只需要对不同玩家实例化类，而不同的玩家，不同的手机有什么不一样，这些就放在类里处理。

这里主要涉及到了几个关键字：public,protected等，这是修饰符

### 访问修饰符

| 访问修饰符    | 当前类 | 派生类（同程序集） | 派生类（不同程序集） | 同程序集的其他类 | 不同程序集的其他类 | 主要用途         |
| ------------- | ------ | ------------------ | -------------------- | ---------------- | ------------------ | ---------------- |
| **private**   | ✅      | ❌                  | ❌                    | ❌                | ❌                  | 封装内部实现细节 |
| **protected** | ✅      | ✅                  | ✅                    | ❌                | ❌                  | 家族继承专用     |
| **internal**  | ✅      | ✅                  | ❌                    | ✅                | ❌                  | 程序集内部共享   |
| **public**    | ✅      | ✅                  | ✅                    | ✅                | ✅                  | 完全公开访问     |

## 继承

### 介绍

继承，就是子类可以继承父类的成员，并在此基础上增加和修改父类成员。这个特性可以不用再写一遍父类的属性，就可以直接调用父类的属性(相当于父类可继承的属性就是你的属性)，一段代码多次使用，提高代码的复用性并减少代码的冗余。

以手机为例，手机有不同的品牌，不同型号，各品牌间系统不一样，配置不一样，导致可玩的游戏也不一样。

## 多态