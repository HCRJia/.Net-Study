Express表达式树是一种数据结构，它可以表示一些代码块，如Lambda表达式或查询表达式。表达式树使你能够查看和操作数据，就像你可以查看和操作代码一样。它们通常用于创建动态查询和解析表达式。

# 表达式树的定义

```csharp
Func<int, int, int> func = (m, n) => m * n + 2;
Expression<Func<int, int, int>> exp = (m, n) => m * n + 2;
int iResult1 = func.Invoke(12, 23);
int iResult2 = exp.Compile().Invoke(12, 23);
```

上面代码是分别使用的委托和表达式的定义和调用。iResult1和iResult2的值是相同的，都是278。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1763648012671-ed4a09c1-2d16-4681-a41a-195f6a82d052.png)

这里可以看到表达式树的特点：可以通过lambda表达式来声明，但在声明中不能包含大括号。

表达式的结构如下，通过符号和计算的优先级进行分级，最下面就是m，n，用*连接，中间这层就是m*m 和2，用+拼接，最上面就是m*n+2，有点像数据结构里的二叉树，表达式拆分下来也是树状，可以将每个独立元素都拆开来作为树的叶子，因此叫它表达式树。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1763884988906-eb038da2-1318-4c07-b7dc-a0441f9d28f7.png)



# 表达式树应用

## 表达式树拼装

可以先来手动来拼装上面的表达式，用上面的树状图，那么首先是声明变量m和n，然后声明常数2，现将m和n乘起来，再和常数2相加，代码如下：

```csharp
ParameterExpression m = Expression.Parameter(typeof(int), "m");
ParameterExpression n = Expression.Parameter(typeof(int), "n");
ConstantExpression constant = Expression.Constant(2);

BinaryExpression mutiply = Expression.Multiply(m, n);
BinaryExpression result = Expression.Add(mutiply, constant);
Expression<Func<int, int, int>> expression = Expression.Lambda<Func<int, int, int>>(result, new ParameterExpression[] { m, n });
int iResult = expression.Compile().Invoke(12, 23);
Console.WriteLine(iResult);
```

ParameterExpression和ConstantExpression对象就是存储变量和常亮的对象，也就是叶子都会放在这两个对象中，Expression.Parameter就是声明对象的语句，有两个参数，数据类型跟变量名，Expression.Constant就是声明常数的方法。

BinaryExpression就是存放表达式的操作，有Expression.Multiply，Expression.Add等，将最终的BinaryExpression存进Expression类里，便是表达式了。当然，减和除还有其它操作也能在express的方法里找到。

下面来看看另一种表达式封装：

```csharp
Expression<Func<People, bool>> lambda = x => x.Id.ToString().Equals("5");
```

这种就不是上面的加减乘除，但依旧可以分解成表达式树。

```csharp
public class People
{
    public int Age { get; set; }
    public string Name { get; set; }
    public int Id;
}
```

手动拼装表达式代码如下：

```csharp
ParameterExpression parameterExpression = Expression.Parameter(typeof(People), "x");
ConstantExpression constantExp = Expression.Constant("5");
FieldInfo field = typeof(People).GetField("Id");
MemberExpression fieldExp = Expression.Field(parameterExpression, field);
MethodInfo toString = typeof(int).GetMethod("ToString", new Type[] { });
MethodCallExpression toStringExp = Expression.Call(fieldExp, toString, new Expression[0]);
MethodInfo equals = typeof(string).GetMethod("Equals", new Type[] { typeof(string) });
MethodCallExpression equalsExp = Expression.Call(toStringExp, equals, new Expression[] { constantExp });
Expression<Func<People, bool>> expression = Expression.Lambda<Func<People, bool>>(equalsExp, new ParameterExpression[]
{
parameterExpression
});
bool bResult = expression.Compile()(new People()
{
    Id = 5,
    Name = "张三",
    Age = 28
});
```

FieldInfo，MethodInfo是反射类，通过反射去获取类的属性和方法，Expression.Field方法就是获取成员，Expression.Call就是获取方法，最后拼接。

## Linq查询

表达式就可以应用在查询上，以前可以用sql拼装来查询。

```csharp
string sql = "SELECT * FROM USER WHERE 1=1";
Console.WriteLine("用户输入个名称，为空就跳过");
string name = Console.ReadLine();
if (!string.IsNullOrWhiteSpace(name))
{
    sql += $" and name like '%{name}%'";
}

Console.WriteLine("用户输入个账号，为空就跳过");
string account = Console.ReadLine();
if (!string.IsNullOrWhiteSpace(account))
{
    sql += $" and account like '%{account}%'";
}
```

现在也可以用表达式去查询：

```csharp
Expression<Func<People, bool>> exp = null;
Console.WriteLine("用户输入个名称，为空就跳过");
string name = Console.ReadLine();
if (!string.IsNullOrWhiteSpace(name))
{
    exp = p => p.Name.Contains(name);
    //dbSet=dbSet.Where(p => p.Name.Contains(name));
}
Console.WriteLine("用户输入个最小年纪，为空就跳过");
string age = Console.ReadLine();
if (!string.IsNullOrWhiteSpace(age) && int.TryParse(age, out int iAge))
{
    exp = p => p.Age > iAge;
    //dbSet = dbSet.Where(p => p => p.Age > iAge);
}
```

但这有个问题，当情况很多的话这种写法代码量会很多：上面是name和age二选一的情况，如果两个都有，那又要写一个exp = p => p.Name.Contains(name) && p.Age > iAge，如果需要查询的参数多，要把每种情况都写出来，会很复杂，

这有两种

## 表达式复制对象

来看一下下面两个类，People和PeopleCopy，这两个除了类名不一样，属性完全一样。

```csharp
public class People
{
    public int Age { get; set; }
    public string Name { get; set; }
    public int Id;
}

public class PeopleCopy
{

    public int Age { get; set; }
    public string Name { get; set; }
    public int Id;
}
```

如果将People的值复制给PeopleCopy，有几种方式：

第一种是直接进行类型转换：

```csharp
PeopleCopy peopleCopy = new PeopleCopy()
{
    Id = people.Id,
    Name = people.Name,
    Age = people.Age
};
```

这种就是最简单最直接的，就是硬编码，也是最不灵活的，每次都要写一遍。

第二种是反射：

```csharp
public static TOut Trans<TIn, TOut>(TIn tIn)
{
    TOut tOut = Activator.CreateInstance<TOut>();
    foreach (var itemOut in tOut.GetType().GetProperties())
    {
        var propIn = tIn.GetType().GetProperty(itemOut.Name);
        itemOut.SetValue(tOut, propIn.GetValue(tIn));
    }
    foreach (var itemOut in tOut.GetType().GetFields())
    {
        var fieldIn = tIn.GetType().GetField(itemOut.Name);
        itemOut.SetValue(tOut, fieldIn.GetValue(tIn));
    }
    return tOut;
}
```

反射，循环读取原对象的所有成员，将值赋给新对象相同名字的成员。

第三种是序列化和反序列化：

```csharp
public static TOut Trans<TIn, TOut>(TIn tIn)
{
    return JsonConvert.DeserializeObject<TOut>(JsonConvert.SerializeObject(tIn));
}
```

先将原对象的实例序列化，然后反序列化后赋给新的对象的实例。

上述两种方法转换将公用化了，但有个问题，就是性能会比较慢。那么有什么又能保证速度又能效率呢，就是使用表达式树

```csharp
public static TOut Trans<TIn, TOut>(TIn tIn)
{
    string key = string.Format("funckey_{0}_{1}", typeof(TIn).FullName, typeof(TOut).FullName);
    if (!_Dic.ContainsKey(key))
    {
        ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), "p");
        List<MemberBinding> memberBindingList = new List<MemberBinding>();
        foreach (var item in typeof(TOut).GetProperties())
        {
            MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));
            MemberBinding memberBinding = Expression.Bind(item, property);
            memberBindingList.Add(memberBinding);
        }
        foreach (var item in typeof(TOut).GetFields())
        {
            MemberExpression property = Expression.Field(parameterExpression, typeof(TIn).GetField(item.Name));
            MemberBinding memberBinding = Expression.Bind(item, property);
            memberBindingList.Add(memberBinding);
        }
        MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());
        Expression<Func<TIn, TOut>> lambda = Expression.Lambda<Func<TIn, TOut>>(memberInitExpression, new ParameterExpression[]
        {
            parameterExpression
        });
        Func<TIn, TOut> func = lambda.Compile();//拼装是一次性的
        _Dic[key] = func;
    }
    return ((Func<TIn, TOut>)_Dic[key]).Invoke(tIn);
}
public class ExpressionGenericMapper<TIn, TOut>//Mapper`2
{
    private static Func<TIn, TOut> _FUNC = null;
    static ExpressionGenericMapper()
    {
        ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), "p");
        List<MemberBinding> memberBindingList = new List<MemberBinding>();
        foreach (var item in typeof(TOut).GetProperties())
        {
            MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));
            MemberBinding memberBinding = Expression.Bind(item, property);
            memberBindingList.Add(memberBinding);
        }
        foreach (var item in typeof(TOut).GetFields())
        {
            MemberExpression property = Expression.Field(parameterExpression, typeof(TIn).GetField(item.Name));
            MemberBinding memberBinding = Expression.Bind(item, property);
            memberBindingList.Add(memberBinding);
        }
        MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());
        Expression<Func<TIn, TOut>> lambda = Expression.Lambda<Func<TIn, TOut>>(memberInitExpression, new ParameterExpression[]
        {
                parameterExpression
        });
        _FUNC = lambda.Compile();//拼装是一次性的
    }
    public static TOut Trans(TIn t)
    {
        return _FUNC(t);
    }
}
```

上面分别用hash字典和泛型缓存实现表达式树。

可以比较一下上面各种方法的速度，创建一个people，每个方法都执行1000000次，比较时间，结果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1764253846833-6da48a9a-9f94-4eb2-a8e5-ad19247df484.png)

可以看到最慢的就是序列化和反序列化，其次是反射，然后是hash字典的表达式树，标准方法和泛型缓存表达式树差不多。