# 什么是设计模式

设计模式是在软件设计中反复出现的问题的通用解决方案。它们是经过多次验证和应用的指导原则，旨在帮助软件开发人员解决特定类型的问题，提高代码的可维护性、可扩展性和重用性。

# 设计模式分类

1. **创建型模式（Creational）**：关注对象的实例化过程，包括了如何实例化对象、隐藏对象的创建细节等。常见的创建型模式有单例模式、工厂模式、抽象工厂模式等。
2. **结构型模式（Structural）**：关注对象之间的组合方式，以达到构建更大结构的目标。这些模式帮助你定义对象之间的关系，从而实现更大的结构。常见的结构型模式有适配器模式、装饰器模式、代理模式等。
3. **行为型模式（Behavioral）**：关注对象之间的通信方式，以及如何合作共同完成任务。这些模式涉及到对象之间的交互、责任分配等。常见的行为型模式有观察者模式、策略模式、命令模式等。

# 创建模式

## 单例模式

在某些情况下，需要确保一个类只有一个实例，并且需要一个全局访问点来访问这个实例。例如，在一个应用程序中，一个配置管理器类需要保持一致的配置数据，以避免不同部分之间的配置冲突。

```csharp
private static volatile Singleton _Singleton = null;
//volatile 促进线程安全 让线程按顺序操作
private static readonly object Singleton_Lock = new object();
/// <summary>
/// 2 公开的静态方法提供对象实例
/// </summary>
/// <returns></returns>
public static Singleton CreateInstance()
{
    if (_Singleton == null)//是_Singleton已经被初始化之后，就不要进入锁等待了
    {
        lock (Singleton_Lock)
        //保证任意时刻只有一个线程进入lock范围
        //也限制了并发，尤其是_Singleton已经被初始化之后
        {
            if (_Singleton == null)//保证只实例化一次
            {
                _Singleton = new Singleton();
            }
        }
    }
    return _Singleton;
}

private static Singleton2 _SingletonT2 = new Singleton2();//打印个日志
public static Singleton2 CreateInstance()
{
    return _Singleton2;
}
```

上述代码实现了单例模式，当程序第一次调用CreateInstance时，就会生成Singleton对象，当重复调用时，不会生成新的对象。程序中使用lock锁，确保只实例化一次。代码实现了两种单例方式，一种是懒汉是，也就是调用CreateInstance才会生成，一种是饿汉式，当程序启动时就会生成。

单例的好处就是全局唯一的一个实例，能够避免重复调用节省内存，但是这个对象会一直占用着内存，所以一般不使用单例模式。

## 工厂模式

工厂模式就是定义了一个创建对象的类，由这个类来封装实例化对象的行为，将这个类称作工厂类，因此叫工厂模式。

工厂模式又分为简单工厂模式，工厂模式，抽象工厂模式。

```csharp
public static IRace CreateRace(RaceType raceType)
{
    IRace iRace = null;
    switch (raceType)
    {
        case RaceType.Human:
            iRace = new Human();
            break;
        case RaceType.Undead:
            iRace = new Undead();
            break;
        case RaceType.ORC:
            iRace = new ORC();
            break;
        case RaceType.NE:
            iRace = new NE();
            break;
        //增加一个分支
        default:
            throw new Exception("wrong raceType");
    }
    return iRace;
}
```

上面就是简单工厂模式，由一个创建对象类，支持创建多种对象。这个类有个问题，就是想要修改或者拓展功能，就只能修改case里的代码，违背了开闭原则。

```csharp
public class HumanFactory : IFactory
{
    public virtual IRace CreateRace()
    {
        return new Human();
    }
}
public class HumanFactoryAdvanced: HumanFactory
{
    public override IRace CreateRace()
    {
        Console.WriteLine("123");
        return new Human();
    }
}
```

将上面拆开来，每个类写一个创建对象的方法，在创建方法中写上每次创建对象需要运行的代码，如记录日志等操作。该写法就是满足了开闭原则，可以进行拓展。

工厂模式是创建一个类的，抽象工厂是创建多个相关类的。

```csharp
public abstract class FactoryAbstract
{
    public abstract IRace CreateRace();
    public abstract IArmy CreateArmy();
    public abstract IHero CreateHero();
    public abstract IResource CreateResource();
}
```

上面这段代码，便是一次性创建四个对象，因为在业务上这四个对象就是一起存在的。

# 结构模式

## 适配器模式

```csharp
public interface IHelper
{
    void Add<T>();
    void Delete<T>();
    void Update<T>();
    void Query<T>();
}
public class MysqlHelper : IHelper
{
    public void Add<T>()
    {
        Console.WriteLine("This is {0} Add", this.GetType().Name);
    }
    public void Delete<T>()
    {
        Console.WriteLine("This is {0} Delete", this.GetType().Name);
    }
    public void Update<T>()
    {
        Console.WriteLine("This is {0} Update", this.GetType().Name);
    }
    public void Query<T>()
    {
        Console.WriteLine("This is {0} Query", this.GetType().Name);
    }
}
public class RedisHelper
{
    public void AddRedis<T>()
    {
        Console.WriteLine("This is {0} Add", this.GetType().Name);
    }
    public void DeleteRedis<T>()
    {
        Console.WriteLine("This is {0} Delete", this.GetType().Name);
    }
    public void UpdateRedis<T>()
    {
        Console.WriteLine("This is {0} Update", this.GetType().Name);
    }
    public void QueryRedis<T>()
    {
        Console.WriteLine("This is {0} Query", this.GetType().Name);
    }
}
```

上面是接口IHelper和两个类，MysqlHelper是继承了接口，RedisHelper没有继承接口，但业务逻辑和IHelper接口类似，在实际使用过程中，可以使用IHelper helper = new MysqlHelper();来实例化MysqlHelper，但IHelper helper = new RedisHelper();会报错。

适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

解决方法是继承或者组合，而组合就是适配器模式的思想，继承是写一个RedisHelperClass :类，继承RedisHelper,和IHelper

```csharp
public class RedisHelperObject : IHelper
{
    private RedisHelper _RedisHelper = null;

    public RedisHelperObject(RedisHelper redisHelper)//可能是一个抽象接口，注入进来
    {
        this._RedisHelper = redisHelper;
    }

    public RedisHelperObject()
    {
        this._RedisHelper = new RedisHelper();
    }

    public void Add<T>()
    {
        this._RedisHelper.AddRedis<T>();
    }

    public void Delete<T>()
    {
        this._RedisHelper.DeleteRedis<T>();
    }

    public void Update<T>()
    {
        this._RedisHelper.UpdateRedis<T>();
    }

    public void Query<T>()
    {
        this._RedisHelper.QueryRedis<T>();
    }
}
```

上面的写法就是适配器模式，创建一个类去继承IHelper，再去实例化一个RedisHelper类，实现RedisHelper的方法.

相比继承，组合优势主要是灵活性，继承是父类有的子类必须有，组合不需要。

## 代理模式

在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。

```csharp
public interface ISubject
{
    bool GetSomething();

    void DoSomething();
}
public class RealSubject : ISubject
{
    public RealSubject()
    {
        Thread.Sleep(2000);
        long lResult = 0;
        for (int i = 0; i < 100000000; i++)
        {
            lResult += i;
        }
        Console.WriteLine("RealSubject被构造。。。");
    }

    /// <summary>
    /// 火车站查询火车票
    /// </summary>
    public bool GetSomething()
    {
        Console.WriteLine("坐车去火车站看看余票信息。。。");
        Thread.Sleep(3000);
        Console.WriteLine("到火车站，看到是有票的");
        return true;
    }

    /// <summary>
    /// 火车站买票
    /// </summary>
    public void DoSomething()
    {
        Console.WriteLine("开始排队。。。");
        Thread.Sleep(2000);
        Console.WriteLine("终于买到票了。。。");
    }
}
```

设计一个业务接口，实现业务功能，当需要限制不能直接访问业务接口时，就写一个中间层，访问中间层，中间层再去调用接口。

```csharp
public class ProxySubject : ISubject
{
    //组合一下
    private static ISubject _Subject = new RealSubject();
    public void DoSomething()
    {
        try
        {
            Console.WriteLine("prepare DoSomething...");
            _Subject.DoSomething();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            throw ex;
        }
    }

    private static Dictionary<string, bool> ProxyDictionary = new Dictionary<string, bool>();
    public bool GetSomething()
    {
        try
        {
            Console.WriteLine("prepare GetSomething...");
            string key = "Proxy_GetSomething";
            bool bResult = false;
            if (!ProxyDictionary.ContainsKey(key))
            {
                bResult = _Subject.GetSomething();
                ProxyDictionary.Add(key, bResult);
            }
            else
            {
                bResult = ProxyDictionary[key];
            }
            return bResult;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            throw ex;
        }
    }
}
```

这段代码通过组合的方式去访问业务代码，并且能够自己加上公共的代码。

## 装饰器模式

当出现需要扩展好几个需求，并且可以更换顺序的时候，可以用装饰器模式的思想。

```csharp
public abstract class AbstractStudent
{
    public int Id { get; set; }
    public string Name { get; set; }

    public abstract void Study();
}
```

这里定义一个Student类，实现Study功能。

```csharp
//实现基础功能
public class BaseStudentDecorator : AbstractStudent
{
    private AbstractStudent _Student = null;//用了组合加override
    public BaseStudentDecorator(AbstractStudent student)
    {
        this._Student = student;
    }

    public override void Study()
    {
        this._Student.Study();
    }
}
//再增加一个功能
public class StudentHomeworkDecorator : BaseStudentDecorator
{
    public StudentHomeworkDecorator(AbstractStudent student)
        : base(student)//表示父类的构造函数
    {

    }

    public override void Study()
    {
        base.Study();

        Console.WriteLine("巩固练习");
       
    }
}
//再增加一个功能
public class StudentCommentDecorator : BaseStudentDecorator
{
    public StudentCommentDecorator(AbstractStudent student)
        : base(student)//表示父类的构造函数
    {

    }

    public override void Study()
    {
        base.Study();

        Console.WriteLine("点评");
       
    }
}
```

代码实现可以定义一个变量student，每次当做参数传进去，返回值仍然是student。

```csharp
AbstractStudent student = new StudentVip()
{
    Id = 381,
    Name = "候鸟"
};
student = new StudentVideoDecorator(student);
student = new StudentHomeworkDecorator(student);
student = new StudentCommentDecorator(student);
student.Study();
```

结果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1765983233325-2686a36e-aa3b-471c-bfe4-a4df4422aa15.png)

# 行为模式

## 模版方法

定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。复杂的多步骤业务，定义一个父类(模板)，模板负责完成流程，把步骤分解，就是模版方法。

```csharp
public void Query(int id, string name, string password)
{
    if (this.CheckUser(id, password))
    {
        double balance = this.QueryBalance(id);
        double interest = this.CalculateInterest(balance);
        this.Show(name, balance, interest);
    }
    else
    {
        Console.WriteLine("账户密码错误");
    }
}
public bool CheckUser(int id, string password)
{
    if (true) { }
    else { }

    return DateTime.Now < DateTime.Now.AddDays(1);
}

public double QueryBalance(int id)
{
    if (true) { }
    else { }

    return new Random().Next(10000, 1000000);
}
public double CalculateInterest(double balance)
{
    if (true) { }
    else { }
    return balance * 0.005;
}

public void Show(string name, double balance, double interest)
{
    Console.WriteLine("尊敬的{0}客户，你的账户余额为：{1}，利息为{2}",
        name, balance, interest);
}
```

以银行系统为例，上面是一种简单的写法，用if else把各种情况包含在一起，在分支少的情况下可以用这种方法，但一旦分支多了，比如说CalculateInterest，每个端逻辑不一样，就要用抽象，然后子类再写具体实现。

```csharp
public abstract class AbstractClient
{
    public void Query(int id, string name, string password)
    {
        if (this.CheckUser(id, password))
        {
            double balance = this.QueryBalance(id);
            double interest = this.CalculateInterest(balance);
            this.Show(name, balance, interest);
        }
        else
        {
            Console.WriteLine("账户密码错误");
        }
    }

    public bool CheckUser(int id, string password)
    {
        return DateTime.Now < DateTime.Now.AddDays(1);
    }

    public double QueryBalance(int id)
    {
        return new Random().Next(10000, 1000000);
    }

    public abstract double CalculateInterest(double balance);

    public virtual void Show(string name, double balance, double interest)
    {
        Console.WriteLine("尊敬的{0}客户，你的账户余额为：{1}，利息为{2}",
            name, balance, interest);
    }

}
```

将上面的功能分类，固定不变的方法如CheckUser，QueryBalance可以直接写具体实现，每个继承类的功能都不同，可以用abstract抽象，大部分情况不变，少数会变的可以用虚方法。

```csharp
public class ClientVip : AbstractClient
{
    public override double CalculateInterest(double balance)
    {
        return balance * 0.005;
    }

    public override void Show(string name, double balance, double interest)
    {
        Console.WriteLine("尊贵的{0} vip客户，您的账户余额为：{1}，利息为{2}",
            name, balance, interest);
    }
}
public class ClientRegular : AbstractClient
{
    public override double CalculateInterest(double balance)
    {
        return balance * 0.003;
    }
}
```

如以上两个类，ClientVip是CalculateInterest和Show都不一样，ClientRegular是CalculateInterest不一样。

这种写法好处就是灵活多变，容易扩展。

## 观察者

观察者模式就是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

```csharp
public void Miao()
{
    Console.WriteLine("{0} Miao.....", this.GetType().Name);

    new Mouse().Run();//依赖
    new Chicken().Woo();
    new Baby().Cry();
    new Brother().Turn();
    new Dog().Wang();
    new Father().Roar();
    new Mother().Whisper();
    new Neighbor().Awake();
}
```

在这个例子中，Miao方法的依赖很多，不稳定，且依赖发生变化Miao方法的功能也会发生变化，不方便加减功能。观察者模式就是把这些依赖移出去，当依赖有更新时，Miao方法也会更新，且不会更改MIao方法。

```csharp
private List<IObserver> _ObserverList = new List<IObserver>();
public void AddObserver(IObserver observer)
{
    this._ObserverList.Add(observer);
}
public void MiaoObserver()
{
    Console.WriteLine("{0} MiaoObserver.....", this.GetType().Name);
    if (this._ObserverList != null && this._ObserverList.Count > 0)
    {
        foreach (var item in this._ObserverList)
        {
            item.Action();
        }
    }
}
Console.WriteLine("***************Observer******************");
Cat cat = new Cat();
cat.AddObserver(new Chicken());
cat.AddObserver(new Baby());
cat.AddObserver(new Brother());
cat.AddObserver(new Dog());
cat.AddObserver(new Father());
cat.AddObserver(new Mother());
cat.AddObserver(new Mouse());
cat.AddObserver(new Neighbor());
cat.AddObserver(new Stealer());
cat.MiaoObserver();
```

把依赖放在外面，当调整的时候就不需要调整MiaoObserver的代码。

## 责任链

责任链模式就是将请求的处理流程，沿着链子顺序执行，还运行链子扩展和订制。

```csharp
public abstract class AbstractAuditor
{
    public string Name { get; set; }
    public abstract void Audit(ApplyContext context);

    private AbstractAuditor _NextAuditor = null;
    public void SetNext(AbstractAuditor auditor)
    {
        this._NextAuditor = auditor;
    }
    protected void AuditNext(ApplyContext context)
    {
        if (this._NextAuditor != null)
        {
            this._NextAuditor.Audit(context);
        }
        else
        {
            context.AuditResult = false;
            context.AuditRemark = "不允许请假！";
        }
    }
}
public class PM : AbstractAuditor
{
    public override void Audit(ApplyContext context)
    {
        Console.WriteLine($"This is {this.GetType().Name} {this.Name} Audit");
        if (context.Hour <= 8)
        {
            context.AuditResult = true;
            context.AuditRemark = "允许请假！";
        }
        else
        {
            base.AuditNext(context);
        }
    }
}
public class Charge: AbstractAuditor
{
    public override void Audit(ApplyContext context)
    {
        Console.WriteLine($"This is {this.GetType().Name} {this.Name} Audit");
        if (context.Hour <= 16)
        {
            context.AuditResult = true;
            context.AuditRemark = "允许请假！";
        }
        else
        {
            base.AuditNext(context);
        }
    }
}
public class AuditorBuilder
{
    /// <summary>
    /// 那就反射+配置文件
    /// 链子的组成都可以通过配置文件
    /// </summary>
    /// <returns></returns>
    public static AbstractAuditor Build()
    {
        AbstractAuditor pm = new PM()
        {
            Name = "张三"
        };
        AbstractAuditor charge = new Charge()
        {
            Name = "李四"
        };
        pm.SetNext(charge);
        charge.SetNext(manager);
        return pm;
    }
}
```

上面的代码就是责任链模式，AbstractAuditor存放了公共属性和方法，并且用到了管观察者模式，定义了PM和Charge类，写有区别的实现，AuditorBuilder类来调用上面的类，执行pm时若符合PM的条件就执行PM的方法，若不符合就传递到Charge，一级一级传递。_NextAuditor用来传递下一级，方便灵活更改下一级和增加级别。