/// <summary>
/// 1 创建型设计模式
/// 2 结构型设计模式
/// 3 行为型设计模式
/// 
/// 设计模式六大原则：单一职责 里氏替换 依赖倒置 最小接口 迪米特 开闭
///                   这些只能叫原则,叫建议,没有实际的招数
/// 面向对象23种设计模式：面向对象语言开发过程中，遇到的种种场景和问题，提出了解决方案和思路，
///                       沉淀下来就变成了设计模式
///                       解决具体问题的具体招数---套路---站在前辈的肩膀上
///                       
/// 创建型设计模式：关注对象的创建
/// 结构型设计模式：关注类与类之间的关系
/// 行为型设计模式：关注对象和行为的分离
/// 
/// 就是学习核心套路
/// 
/// 0122
/// 创建型设计模式5：关注对象的创建，
/// 对象的创建不就是new()一下？其实有很多套路
/// 单例模式：就是限制了对象的创建，重用了对象
/// 原型模式：换个方式创建对象，不走构造函数，而是内存拷贝
/// 简单工厂：不直接new，把对象创建转移到工厂类
/// (简单工厂不属于23种设计模式)
/// 工厂方法：屏蔽对象的创建；留下了扩展空间；
/// 抽象工厂：屏蔽对象的创建；约束强制保障产品簇；
/// 建造者模式：复杂的工厂方法
/// 
/// 
/// 没有什么设计模式是完美无缺的，一个设计模式就是解决一类的问题的，通常设计模式在解决一类问题的同时，还会带来别的问题，我们设计者要做的事儿，就是要扬长避短，充分发挥长处！
/// 
/// 0123
/// 结构型设计模式7：关注类与类之间的关系
/// 纵向关系：继承≈≈实现  超强关联
/// 横向关系：>组合>聚合>关联>依赖
///           依赖是出现在方法内部
///           另外三个是用语义区分的，可能都是一个属性
///           Person类 有个大脑Header属性  组合(同生共死)
///           Person类 有个手/脚    聚合(成人)
///           Person类 有个iPhone属性  关联(非必须)   
/// 组合优于继承，结构型设计模式的核心
/// 
/// 
/// 适配器模式：解决重构的问题，新东西和旧系统不吻合，通过继承/组合进行适配
/// 代理模式：通过代理完成对业务类的访问，包一层方便任意功能扩展
/// 装饰器模式：通过组合+继承，完成对象功能动态扩展
/// 外观模式，组合模式，桥接模式，享元模式
/// 
/// 多种结构型设计模式其实都是用组合包一层，然后加功能，
/// 解决不同的问题，然后有不同的侧重点，也有不同的规范
/// 
/// 0124
/// 行为型设计模式11：关注对象和行为的分离
/// 模板方法设计模式：在基类父类定义流程，把可变逻辑分离到不同子类实现
/// 观察者模式：一个对象动作触发多个对象的行为，通过观察者可以去掉对象的依赖，支持各种自定义和扩展
/// 责任链模式：请求的处理流程，沿着链子顺序执行，还运行链子扩展和订制
/// 
/// 
/// 甩锅大法：把锅丢出去，只管自己，哪管洪水滔天
///           把不稳定的地方移出去，自己只写稳定的，能保证自身的稳定
///           
/// 
/// 没有什么设计模式是完美无缺的，一个设计模式就是解决一类的问题的，通常设计模式在解决一类问题的同时，还会带来别的问题，我们设计者要做的事儿，就是要扬长避短，充分发挥长处！
/// 
/// 很多时候，可能会融合应用多个设计模式，分别解决对应的问题
/// </summary>
Console.WriteLine("Hello, World!");
