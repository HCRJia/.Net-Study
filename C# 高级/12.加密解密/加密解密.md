项目中，有时候会对重要数据进行加密和解密，比如密码。密码分为两类：可逆和不可逆。可逆就是有加密

可逆：RSA,AES,DES等

不可逆：常见的MD5，SHAD等

下面介绍三张加密解密算法：

# MD5

## 介绍

MD5是一种公开的算法，是一种不可逆算法，根据密文是无法推出原文的。字符串，文件，压缩包都可以加密成MD5，并且相同的原文加密后的MD5都是相同的。

加密后的MD5都是32位的字符串，因此MD5总共有2的128次方个，基本上不用考虑加密后的MD5会重复的情况。MD5是无法破解的，除非原文过于简单，在加密库里能查到，一般安全性是很高的。

## 使用

在c#中可以使用MD5Encrypt.Encrypt()给字符串加密，或MD5Encrypt.AbstractFile给指定路径的文件加密，例子如下：

```csharp
MD5Encrypt.Encrypt("123456小李")
```

# DES

## 介绍

DES是一种可逆对称加密，提供一个密钥，密钥是一个8位的字符串，通过这个密钥对文本进行加密跟解密。优点是加密解密速度快，缺点是密钥管理不方便，如果泄露秘钥数据就不安全。

## 使用

```csharp
public class DesEncrypt
{
    private static byte[] _rgbKey = ASCIIEncoding.ASCII.GetBytes(Constant.DesKey.Substring(0, 8));
    private static byte[] _rgbIV = ASCIIEncoding.ASCII.GetBytes(Constant.DesKey.Insert(0, "w").Substring(0, 8));

    /// <summary>
    /// DES 加密
    /// </summary>
    /// <param name="text">需要加密的值</param>
    /// <returns>加密后的结果</returns>
    public static string Encrypt(string text)
    {
        DES dsp = DES.Create();
        using (MemoryStream memStream = new MemoryStream())
        {
            CryptoStream crypStream = new CryptoStream(memStream, dsp.CreateEncryptor(_rgbKey, _rgbIV), CryptoStreamMode.Write);
            using (StreamWriter sWriter = new StreamWriter(crypStream))
            {
                sWriter.Write(text);
                sWriter.Flush();
                crypStream.FlushFinalBlock();
            }
            memStream.Flush();
            return Convert.ToBase64String(memStream.GetBuffer(), 0, (int)memStream.Length);
        }
    }

    /// <summary>
    /// DES解密
    /// </summary>
    /// <param name="encryptText"></param>
    /// <returns>解密后的结果</returns>
    public static string Decrypt(string encryptText)
    {
        DES dsp = DES.Create();
        byte[] buffer = Convert.FromBase64String(encryptText);

        using (MemoryStream memStream = new MemoryStream())
        {
            CryptoStream crypStream = new CryptoStream(memStream, dsp.CreateDecryptor(_rgbKey, _rgbIV), CryptoStreamMode.Write);
            crypStream.Write(buffer, 0, buffer.Length);
            crypStream.FlushFinalBlock();
            return ASCIIEncoding.UTF8.GetString(memStream.ToArray());
        }
    }
}
```

调用上面的方法：

```csharp
string desEn1 = DesEncrypt.Encrypt("张三李四");
string desDe1 = DesEncrypt.Decrypt(desEn1);

Console.WriteLine(desEn1);
Console.WriteLine(desDe1);
```

结果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1765289091583-58d4137d-65f6-454e-ae49-81cd31169896.png)

# RSA

## 介绍

RSA是一种非对称可逆加密，加密后能解密回原文，加密key和解密key不是一个，而是一对，但知道加密key无法推出解密key，反之同理。

RSA加密解密速度不如DES，但安全性更高，可以对外公开加密key，解密key保存好，这样数据不会容易被解密。

## 使用

```csharp
public class RsaEncrypt
{
    public static KeyValuePair<string, string> GetKeyPair()
    {
        RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();
        string publicKey = RSA.ToXmlString(false);
        string privateKey = RSA.ToXmlString(true);
        return new KeyValuePair<string, string>(publicKey, privateKey);
    }

    public static string Encrypt(string content, string encryptKey)
    {
        RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
        rsa.FromXmlString(encryptKey);
        UnicodeEncoding ByteConverter = new UnicodeEncoding();
        byte[] DataToEncrypt = ByteConverter.GetBytes(content);
        byte[] resultBytes = rsa.Encrypt(DataToEncrypt, false);
        return Convert.ToBase64String(resultBytes);
    }

    public static string Decrypt(string content, string decryptKey)
    {
        byte[] dataToDecrypt = Convert.FromBase64String(content);
        RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();
        RSA.FromXmlString(decryptKey);
        byte[] resultBytes = RSA.Decrypt(dataToDecrypt, false);
        UnicodeEncoding ByteConverter = new UnicodeEncoding();
        return ByteConverter.GetString(resultBytes);
    }
}
```

这段代码就是实现了加密和解密。