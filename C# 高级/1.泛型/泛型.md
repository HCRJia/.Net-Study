# 场景

<font style="color:rgb(15, 17, 21);">在开发中，会有不同的数据类型编写功能几乎相同的方法。当业务逻辑一致而仅参数类型不同时，会产生大量重复代码：</font>

```csharp
/// <summary>
/// 打印个int值
/// </summary>
/// <param name="iParameter"></param>
public static void ShowInt(int iParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, iParameter.GetType().Name, iParameter);
}
/// <summary>
/// 打印个string值
/// </summary>
/// <param name="sParameter"></param>
public static void ShowString(string sParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, sParameter.GetType().Name, sParameter);
}
/// <summary>
/// 打印个DateTime值
/// </summary>
/// <param name="oParameter"></param>
public static void ShowDateTime(DateTime dtParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, dtParameter.GetType().Name, dtParameter);
}
```



```csharp
int iValue = 123;
string sValue = "456";
DateTime dtValue = DateTime.Now;
object oValue = "678";

CommonMethod.ShowInt(iValue);
//CommonMethod.ShowInt(sValue); 因为数据类型不同，报错
CommonMethod.ShowString(sValue);
CommonMethod.ShowDateTime(dtValue);
```

<font style="color:rgb(51, 51, 51);">从上面的结果中我们可以看出这三个方法，除了传入的参数不同外，其里面实现的功能都是一样的。那么，这种情况下，有一个解决办法将参数改成object，因为object是所有类型的基类，也能得到同样的结果。</font>

```csharp
public static void ShowObject(object oParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod), oParameter.GetType().Name, oParameter);
}
```

```csharp
CommonMethod.ShowObject(iValue);
CommonMethod.ShowObject(sValue);
CommonMethod.ShowObject(dtValue);
```

# 泛型介绍

<font style="color:rgb(51, 51, 51);">在泛型类型或方法定义中，类型参数是一个占位符，加在类型或方法名后面，如</font>_<font style="color:#DF2A3F;background-color:#E7E9E8;">Show<T>(T tParameter)</font>_<font style="color:rgb(51, 51, 51);">。若要使用此方法，代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 此特定类的类型参数T可以是编译器可识别的任何类型，如int。 可创建任意数量的构造类型实例，其中每个使用不同的类型参数。我们常用的List<>,Dictionary<,>，尖括号里可以根据情况填写数据类型，便是泛型的一种使用。</font>

因此，在引入泛型后，上面代码可以写成：

```csharp
public static void Show<T>(T tParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
       typeof(CommonMethod), tParameter.GetType().Name, tParameter);
}
```

```csharp
CommonMethod.Show<int>(iValue);//调用泛型，需要指定类型参数
//CommonMethod.Show(iValue);//如果可以从参数类型推断，可以省略类型参数---语法糖(编译器提供的功能)
CommonMethod.Show<string>(sValue);
//CommonMethod.Show<int>(sValue);//报错，因为类型错了
CommonMethod.Show<DateTime>(dtValue);
```

运行结果如下：

![](https://cdn.nlark.com/yuque/0/2025/png/42432244/1758806314105-bf5872e4-ce8a-48f9-96a6-1e6af7f200ff.png)

## 泛型的原理

我们知道，在程序的执行过程中，编写的程序会一步一步编译成二进制代码，再由计算机执行。在程序中声明的泛型，在编译器编译期间，都会生成对应的有具体数据类型的方法或类型。<font style="color:rgb(51, 51, 51);">泛型是C#2.0推出的新语法，是需要编译器的支持。</font>

## 泛型的性能

使用泛型除了使代码更简便外，还能避免传<font style="color:rgb(51, 51, 51);">object的装箱拆箱带来的性能损耗。</font>

```csharp
using System.Diagnostics;

namespace Generic
{
    /// <summary>
    /// 性能对比
    /// </summary>
    public class Monitor
    {
        public static void Show()
        {
            {
                int iValue = 12345;
                long commonSecond = 0;
                long objectSecond = 0;
                long genericSecond = 0;

                {
                    Stopwatch watch = new();
                    watch.Start();
                    for (int i = 0; i < 100_000_000; i++)
                    {
                        ShowInt(iValue);
                    }
                    watch.Stop();
                    commonSecond = watch.ElapsedMilliseconds;
                }
                {       ......
                        ShowObject(iValue);
                        ......
                }
                {       ......
                        Show<int>(iValue);
                        ......
                }
                Console.WriteLine("commonSecond={0},objectSecond={1},genericSecond={2}"
                    , commonSecond, objectSecond, genericSecond);
            }
        }

        #region PrivateMethod
        private static void ShowInt(int iParameter)
        {
        }
        private static void ShowObject(object oParameter)
        {
        }
        private static void Show<T>(T tParameter)
        {
        }
        #endregion

    }
}
```

<font style="color:rgb(51, 51, 51);">Monitor类，分别使用三个方法执行1亿次，计算时间</font>

![](https://cdn.nlark.com/yuque/0/2025/png/42432244/1758976189459-a187bba9-a2e4-4354-b072-a9e8de9ce5b0.png)

重复执行十次后，可以看到使用泛型的方法跟基本类型性能是差不多的，而转换成object方法性能差点，是因为转换成object要经过拆箱装箱，有额外的开支。

# 泛型使用

除了泛型方法，泛型也可以应用到类，接口，委托上面。

```csharp
    /// <summary>
    /// 泛型类
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class GenericClass<T>
    {
        public T _T;
    }

    public class GenericClassChild1: GenericClass<int>
    {
    }

    public class GenericClassChild2<T> : GenericClass<T>
    {
    }

    /// <summary>
    /// 泛型接口
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface IGenericInterface<T>
    {
        T GetT(T t);
    }

    public delegate void SayHi<T>(T t);//泛型委托
```

```csharp
// T是int类型
GenericClass<int> genericInt = new GenericClass<int>();
genericInt._T = 123;
// T是string类型
GenericClass<string> genericString = new GenericClass<string>();
genericString._T = "123";
```

泛型类在声明的时候可以不指定具体的类型，但是在实例化的时候必须指定具体类型。

类在继承泛型类时要指定具体的类型，或者子类也使用泛型。

尖括号内也可以指多个类型，如<T, S>

