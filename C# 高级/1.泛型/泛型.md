# 场景

在开发中，会有不同的数据类型编写功能几乎相同的方法。当业务逻辑一致而仅参数类型不同时，会产生大量重复代码：

```csharp
/// <summary>
/// 打印个int值
/// </summary>
/// <param name="iParameter"></param>
public static void ShowInt(int iParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, iParameter.GetType().Name, iParameter);
}
/// <summary>
/// 打印个string值
/// </summary>
/// <param name="sParameter"></param>
public static void ShowString(string sParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, sParameter.GetType().Name, sParameter);
}
/// <summary>
/// 打印个DateTime值
/// </summary>
/// <param name="oParameter"></param>
public static void ShowDateTime(DateTime dtParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, dtParameter.GetType().Name, dtParameter);
}
```



```csharp
int iValue = 123;
string sValue = "456";
DateTime dtValue = DateTime.Now;
object oValue = "678";

CommonMethod.ShowInt(iValue);
//CommonMethod.ShowInt(sValue); 因为数据类型不同，报错
CommonMethod.ShowString(sValue);
CommonMethod.ShowDateTime(dtValue);
```

从上面的结果中我们可以看出这三个方法，除了传入的参数不同外，其里面实现的功能都是一样的。那么，这种情况下，有一个解决办法将参数改成object，因为object是所有类型的基类，也能得到同样的结果。

```csharp
public static void ShowObject(object oParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod), oParameter.GetType().Name, oParameter);
}
CommonMethod.ShowObject(iValue);
CommonMethod.ShowObject(sValue);
CommonMethod.ShowObject(dtValue);
```

# 泛型介绍

在泛型类型或方法定义中，类型参数是一个占位符，加在类型或方法名后面，如*Show<T>(T tParameter)*。若要使用此方法，代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 此特定类的类型参数T可以是编译器可识别的任何类型，如int。 可创建任意数量的构造类型实例，其中每个使用不同的类型参数。我们常用的List<>,Dictionary<,>，尖括号里可以根据情况填写数据类型，便是泛型的一种使用。

因此，在引入泛型后，上面代码可以写成：

```csharp
public static void Show<T>(T tParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
       typeof(CommonMethod), tParameter.GetType().Name, tParameter);
}
CommonMethod.Show<int>(iValue);//调用泛型，需要指定类型参数
//CommonMethod.Show(iValue);//如果可以从参数类型推断，可以省略类型参数---语法糖(编译器提供的功能)
CommonMethod.Show<string>(sValue);
//CommonMethod.Show<int>(sValue);//报错，因为类型错了
CommonMethod.Show<DateTime>(dtValue);
```

运行结果如下：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1758806314105-bf5872e4-ce8a-48f9-96a6-1e6af7f200ff.png)

## 泛型的原理

我们知道，在程序的执行过程中，编写的程序会一步一步编译成二进制代码，再由计算机执行。在程序中声明的泛型，在编译器编译期间，都会生成对应的有具体数据类型的方法或类型。泛型是C#2.0推出的新语法，是需要编译器的支持。

泛型除了有强大的代码复用性外，还有着优秀的性能和类型安全，下面也会讲到。

## 泛型的性能

使用泛型除了使代码更简便外，还能避免传object的装箱拆箱带来的性能损耗。

```csharp
using System.Diagnostics;

namespace Generic
{
    /// <summary>
    /// 性能对比
    /// </summary>
    public class Monitor
    {
        public static void Show()
        {
            {
                int iValue = 12345;
                long commonSecond = 0;
                long objectSecond = 0;
                long genericSecond = 0;

                {
                    Stopwatch watch = new();
                    watch.Start();
                    for (int i = 0; i < 100_000_000; i++)
                    {
                        ShowInt(iValue);
                    }
                    watch.Stop();
                    commonSecond = watch.ElapsedMilliseconds;
                }
                {       ......
                        ShowObject(iValue);
                        ......
                }
                {       ......
                        Show<int>(iValue);
                        ......
                }
                Console.WriteLine("commonSecond={0},objectSecond={1},genericSecond={2}"
                    , commonSecond, objectSecond, genericSecond);
            }
        }

        #region PrivateMethod
        private static void ShowInt(int iParameter)
        {
        }
        private static void ShowObject(object oParameter)
        {
        }
        private static void Show<T>(T tParameter)
        {
        }
        #endregion

    }
}
```

Monitor类，分别使用三个方法执行1亿次，计算时间

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1758976189459-a187bba9-a2e4-4354-b072-a9e8de9ce5b0.png)

重复执行十次后，可以看到使用泛型的方法跟基本类型性能是差不多的，而转换成object方法性能差点，是因为转换成object要经过拆箱装箱，有额外的开支。

# 泛型使用

除了泛型方法，泛型也可以应用到类，接口，委托上面。

```csharp
    /// <summary>
    /// 泛型类
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class GenericClass<T>
    {
        public T _T;
    }

    public class GenericClassChild1: GenericClass<int>
    {
    }

    public class GenericClassChild2<T> : GenericClass<T>
    {
    }

    /// <summary>
    /// 泛型接口
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface IGenericInterface<T>
    {
        T GetT(T t);
    }

    public delegate void SayHi<T>(T t);//泛型委托
// T是int类型
GenericClass<int> genericInt = new GenericClass<int>();
genericInt._T = 123;
// T是string类型
GenericClass<string> genericString = new GenericClass<string>();
genericString._T = "123";
```

泛型类在声明的时候可以不指定具体的类型，但是在实例化的时候必须指定具体类型。

类在继承泛型类时要指定具体的类型，或者子类也使用泛型。

尖括号内也可以指多个类型，如<T, S>

## 泛型的性能安全

来看看具体的例子：

```csharp
namespace MyGeneric
{
    public interface IWork
    {
        void Work();
    }


    public class People
    {
        public int Id { get; set; }
        public string Name { get; set; }

        public void Hi()
        { }

    }

    public class Chinese : People, IWork
    {
        public void SayHi()
        {
            Console.WriteLine("你好");
        }

        public void Work()
        {
            throw new NotImplementedException();
        }
    }

    public class ZheJiang : Chinese
    {
        public string XiHu { get; set; }
        public void SayHello()
        {
            Console.WriteLine("我是浙江人");
        }
    }


    public class Japanese : IWork
    {
        public int Id { get; set; }
        public string Name { get; set; }


        public void Work()
        {
            Console.WriteLine("工作");
        }
    }
}
People people = new People()
{
    Id = 123,
    Name = "Mike"
};
Chinese chinese = new Chinese()
{
    Id = 234,
    Name = "张三"
};
ZheJiang zhejiang = new ZheJiang()
{
    Id = 345,
    Name = "李四"
};
Japanese japanese = new Japanese()
{
    Id = 456,
    Name = "路飞"
};
```

定义了几个接口和具体的实现。

```csharp
public static void ShowObject(object oParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(GenericConstraint), oParameter.GetType().Name, oParameter);
    People people = (People)oParameter;
    Console.WriteLine($"{people.Id}  {people.Name}");
}
```

对这几个类执行ShowObject方法，没什么问题。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759152205546-636b754b-ab01-4848-b56a-d4395f8bd3e4.png)

但是，当我定义一个int类型，并调用ShowObject，会发生什么呢？

```csharp
int num = 123;
GenericConstraint.ShowObject(123);
```

运行后会得到什么结果？





会报错

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759152457194-71c7d129-d24b-4bbd-93d5-8e30d538afb0.png)

我们再用泛型去编写代码：

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759152624969-a1ffdee3-76e6-41d0-8851-015b2e42e58d.png)

因为object类型可以强制转换为People类型，对于原先就是People类型，这方法是没问题的，但对于不是People类型，在运行这段代码时就会报错，而泛型无法通过强制转换去强行运行代码，那么我们怎样能实现这个功能呢：

## 泛型约束

所谓的泛型约束，实际上就是约束的类型T。使T必须遵循一定的规则。比如T必须继承自某个类，或者T必须实现某个接口等等。那么怎么给泛型指定约束？其实也很简单，只需要where关键字，加上约束的条件。那么，T就必须是People或它的子类

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759153184678-46f3a6cd-fb36-451e-b415-7425e2e91dad.png)

如图所示，这样我们编译器就不会报错，而传int类型时，编译器也会提示报错，这样就实现了性能安全。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759153228962-2cedb4f7-8e7b-4e23-bed5-84adad29958c.png)

| 约束          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| T：结构       | 类型参数必须是值类型                                         |
| T：类         | 类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型。 |
| T：new()      | 类型参数必须具有无参数的公共构造函数。 当与其他约束一起使用时，new() 约束必须最后指定。 |
| T：<基类名>   | 类型参数必须是指定的基类或派生自指定的基类。                 |
| T：<接口名称> | 类型参数必须是指定的接口或实现指定的接口。 可以指定多个接口约束。 约束接口也可以是泛型的。 |

```csharp
public static void Show<T>(T tParameter)
    //where T : People
    //where T : ISports
    where T : People, ISports, IWork, new()

{
    Console.WriteLine("This is {0},parameter={1},type={2}",
       typeof(GenericConstraint), tParameter.GetType().Name, tParameter);

    Console.WriteLine($"{tParameter.Id}  {tParameter.Name}");
    tParameter.Hi();
    //tParameter.Pingpang();
}

public T GetT<T, S>()
    //where T : class//引用类型约束
    //where T : struct//值类型
    where T : new()//无参数构造函数
    where S : class
{
    //return null;
    //return default(T);//default是个关键字，会根据T的类型去获得一个默认值
    return new T();
    //throw new Exception();
}
```

​	上面就是各类型的约束，泛型约束也可以做多个约束。

## 泛型的协变和逆变

我们先来看下面这段代码：

```csharp
public class Bird
{
    public int Id { get; set; }
}
public class Sparrow : Bird
{
    public string Name { get; set; }
}

List<Bird> birdList1 = new List<Bird>();
List<Bird> birdList2 = new List<Sparrow>();

List<Bird> birdList3 = new List<Sparrow>().Select(c => (Bird)c).ToList();
```

这段代码中，第11行会报错，因为Sparrow是Bird的子类，但List<Sparrow>和List<Bird>不是父子关系，不能直接进行转换，需要使用new List<Sparrow>().Select(c => (Bird)c).ToList()的方式，将List<Sparrow>的每一项单独转换成Bird类型，再封装成List。

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759654302353-3306a216-65cf-4e26-9979-f97aa5417930.png)

引入的协变和逆变能解决这个问题。

`协变`：泛型参数定义的类型只能作为方法的返回类型，不能作为方法的参数类型，且该类型直接或者间接地继承自接口方法的返回值类型;可以使用out关键字声明协变参数。如：string->object （子类到父类的转换）

`逆变`：泛型参数定义的类型只能作为方法参数的类型，不能作为返回值类型，且该类型是接口方法的参数类型的基类型；可以使用in关键字声明逆变参数。如：object->string （父类到子类的转换）

上述的类型转换还可以写成：

```csharp
IEnumerable<Bird> birdList1 = new List<Bird>();
IEnumerable<Bird> birdList2 = new List<Sparrow>();
```

![img](https://cdn.nlark.com/yuque/0/2025/png/42432244/1759718218889-624ef24c-c2ff-4296-b3d9-5885521bd329.png)

IEnumerable的定义中，out就是协变的用法，下面，自定义一个协变和逆变

```csharp
//协变
{
    IEnumerable<Bird> birdList1 = new List<Bird>();
    IEnumerable<Bird> birdList2 = new List<Sparrow>();

    Func<Bird> func = new Func<Sparrow>(() => null);

    ICustomerListOut<Bird> customerList1 = new CustomerListOut<Bird>();
    ICustomerListOut<Bird> customerList2 = new CustomerListOut<Sparrow>();
}
//逆变
{
    ICustomerListIn<Sparrow> customerList2 = new CustomerListIn<Sparrow>();
    ICustomerListIn<Sparrow> customerList1 = new CustomerListIn<Bird>();

    ICustomerListIn<Bird> birdList1 = new CustomerListIn<Bird>();
    birdList1.Show(new Sparrow());
    birdList1.Show(new Bird());

    Action<Sparrow> act = new Action<Bird>((Bird i) => { });
}

/// <summary>
/// out 协变 只能是返回结果
/// </summary>
/// <typeparam name="T"></typeparam>
public interface ICustomerListOut<out T>
{
    T Get();
}

public class CustomerListOut<T> : ICustomerListOut<T>
{
    public T Get()
    {
        return default(T);
    }
}

/// <summary>
/// in 逆变 只能是参数
/// </summary>
/// <typeparam name="T"></typeparam>
public interface ICustomerListIn<in T>
{
    void Show(T t);
}

public class CustomerListIn<T> : ICustomerListIn<T>
{
    public void Show(T t)
    {
    }
}
```
