# 场景

<font style="color:rgb(15, 17, 21);">在开发中，会有不同的数据类型编写功能几乎相同的方法。当业务逻辑一致而仅参数类型不同时，会产生大量重复代码：</font>

```csharp
/// <summary>
/// 打印个int值
/// </summary>
/// <param name="iParameter"></param>
public static void ShowInt(int iParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, iParameter.GetType().Name, iParameter);
}
/// <summary>
/// 打印个string值
/// </summary>
/// <param name="sParameter"></param>
public static void ShowString(string sParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, sParameter.GetType().Name, sParameter);
}
/// <summary>
/// 打印个DateTime值
/// </summary>
/// <param name="oParameter"></param>
public static void ShowDateTime(DateTime dtParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod).Name, dtParameter.GetType().Name, dtParameter);
}
```



```csharp
int iValue = 123;
string sValue = "456";
DateTime dtValue = DateTime.Now;
object oValue = "678";

CommonMethod.ShowInt(iValue);
//CommonMethod.ShowInt(sValue); 因为数据类型不同，报错
CommonMethod.ShowString(sValue);
CommonMethod.ShowDateTime(dtValue);
```

<font style="color:rgb(51, 51, 51);">从上面的结果中我们可以看出这三个方法，除了传入的参数不同外，其里面实现的功能都是一样的。那么，这种情况下，有一个解决办法将参数改成object，因为object是所有类型的基类，也能得到同样的结果。</font>

```csharp
public static void ShowObject(object oParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
        typeof(CommonMethod), oParameter.GetType().Name, oParameter);
}
```

```csharp
CommonMethod.ShowObject(iValue);
CommonMethod.ShowObject(sValue);
CommonMethod.ShowObject(dtValue);
```

# 泛型介绍

<font style="color:rgb(51, 51, 51);">在泛型类型或方法定义中，类型参数是一个占位符，加在类型或方法名后面，如</font>_<font style="color:#DF2A3F;background-color:#E7E9E8;">Show<T>(T tParameter)</font>_<font style="color:rgb(51, 51, 51);">。若要使用此方法，代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 此特定类的类型参数T可以是编译器可识别的任何类型，如int。 可创建任意数量的构造类型实例，其中每个使用不同的类型参数。我们常用的List<>,Dictionary<,>，尖括号里可以根据情况填写数据类型，便是泛型的一种使用。</font>

因此，在引入泛型后，上面代码可以写成：

```csharp
public static void Show<T>(T tParameter)
{
    Console.WriteLine("This is {0},parameter={1},type={2}",
       typeof(CommonMethod), tParameter.GetType().Name, tParameter);
}
```

```csharp
CommonMethod.Show<int>(iValue);//调用泛型，需要指定类型参数
//CommonMethod.Show(iValue);//如果可以从参数类型推断，可以省略类型参数---语法糖(编译器提供的功能)
CommonMethod.Show<string>(sValue);
//CommonMethod.Show<int>(sValue);//报错，因为类型错了
CommonMethod.Show<DateTime>(dtValue);
```

运行结果如下：

![](https://cdn.nlark.com/yuque/0/2025/png/42432244/1758806314105-bf5872e4-ce8a-48f9-96a6-1e6af7f200ff.png)

## 泛型的原理

我们知道，在程序的执行过程中，编写的程序会一步一步编译成二进制代码，再由计算机执行。在程序中声明的泛型，在编译器编译期间，都会生成对应的有具体数据类型的方法或类型。<font style="color:rgb(51, 51, 51);">泛型是C#2.0推出的新语法，是需要编译器的支持。</font>


