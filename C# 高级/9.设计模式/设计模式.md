设计模式原则，就是在面向对象语言开发过程中，推荐的一些指导性原则，一些项目构成的建议，不许要强制遵守。

这里介绍六中设计模式：

\1.  单一职责原则（Single Responsibility Principle）：一个方法/类/项目只有一个职责。

\2.  里氏替换原则（Liskov Substitution Principle）

\3.  依赖倒置原则（Dependence Inversion Principle）

\4.  接口隔离原则（Interface Segregation Principle）

\5.  迪米特法则  （Law Of Demeter）

\6.  开闭原则    （Open Closed Principle)

# 单一职责原则

类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。单一职责原则，就是一个类只负责一件事儿，这样修改某个类时不会影响其它的类。

```csharp
public void Breath()
{
    if (this._Name.Equals("鸡"))
        Console.WriteLine($"{this._Name} 呼吸空气");
    else if (this._Name.Equals("牛"))
        Console.WriteLine($"{this._Name} 呼吸空气");
    else if (this._Name.Equals("鱼"))
        Console.WriteLine($"{this._Name} 呼吸水");
    else if (this._Name.Equals("蚯蚓"))
        Console.WriteLine($"{this._Name} 呼吸泥土");
}
```

这是一个if else的分支语句，这种写法就是把不同的动物的Breath方法放在一条语句，如果后续不再调整这段代码的话，那么这条语句是没有问题的，那么如果需要调整代码呢，多加几个分支，或者部分分支多加几个执行语句，直接在上面改的话是可能会影响到其它分支的，而且违背了单一原则。

将这些动物的封装成类，在每个类内编写自己的执行方法。

```csharp
public abstract class AbstractAnimal
{
    protected string _Name = null;
    public AbstractAnimal(string name)
    {
        this._Name = name;
    }

    public abstract void Breath();
    public abstract void Action();
}
public class Fish : AbstractAnimal
{
    public Fish() : base("鱼")
    {
    }

    public override void Breath()
    {
        Console.WriteLine($"{base._Name} 呼吸水");
    }
    public override void Action()
    {
        Console.WriteLine($"{base._Name} swimming");
    }
}
```

上面列举了Fish类的写法，其它类写法类似，这种写法就是使每个分支独立起来，后续要调整时只需要调整对应类的代码便可，在项目上更好管理。

单一原则也是有缺点的，代码量明显的增多，如果类型足够简单，方法够少，是可以在类级别去违背单一职责，如果类型多了，还是建议使用单一原则。

对于其它范围的代码，也有单一职责：

方法级别的单一职责原则：一个方法只负责一件事儿

类级别的单一职责原则：一个类只负责一件事儿

类库级别的单一职责原则：一个类库应该职责清晰

项目级别的单一职责原则：一个项目应该职责清晰

系统级别的单一职责原则：为通用功能拆分系统

# 里氏替换原则

有一功能 P1, 由类 A 完成，现需要将功能 P1 进行扩展，扩展后的功能为 P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。里氏替换原则，就是B类继承A类的时候，尽量不要修改A类的方法。

我们可以看一个例子：

```csharp
    public class ParentClass
    {
        public void CommonMethod()
        {
            Console.WriteLine("ParentClass CommonMethod");
        }

    }

public class ChildClass : ParentClass
{
    public new void CommonMethod()
    {
        Console.WriteLine("ChildClass CommonMethod");
    }
}
```

​    当子类写了个隐藏类，ParentClass instance = new ChildClass(); 调用instance.CommonMethod()时，仍然显示父类的，没有显示子类的，有可能就会出错，这就违背了里氏替换原则。

```csharp
public class People
{
    public int Id { get; set; }
    public string Name { get; set; }

    //abstract void Eat();
    public void Traditional()
    {
        Console.WriteLine("传统文化 ");
    }
}
```

这里有一个类，有两个属性和一个方法，当后续写子类的时候，最好都包含上面的方法，假设有一个类不需要Traditional方法，要另写一个方法，那么不推荐去继承People了，推荐去新写一个父类。

父类有的，子类是必须有的，如果出现了子类没有的东西，那么就应该断掉继承。子类可以有自己的属性和行为，父类实现的东西，子类就不要去替换，这就是里氏替换原则。

# 依赖倒置原则



# 接口隔离原则



# 迪米特原则

迪米特原则则又称为 最少知道原则，它表示一个对象应该对其它对象保持最少的了解。通俗来说就是，只与直接的朋友通信。

面向对象中，万物都是对象，类和类的交互产生了各种功能，这个就叫类的耦合。耦合的方式很多，依赖、关联、组合、聚合

我们来看一个例子，创建个学生，班级，学校三个类

```csharp
public class Student
{
    public int Id { get; set; }
    public string StudentName { get; set; }
    public int Height { private get; set; }

    public int Salay;

}
public class Class
{
    public int Id { get; set; }
    public string ClassName { get; set; }

    public List<Student> StudentList { get; set; }

}
public class School
{
    public int Id { get; set; }
    public string SchoolName { get; set; }
    public List<Class> ClassList { get; set; }

    public void Manage()
    {
        Console.WriteLine("Manage {0}", this.GetType().Name);
        foreach (Class c in this.ClassList)
        {
            List<Student> studentList = c.StudentList;
            foreach (Student s in studentList)
            {
                Console.WriteLine(" {0}Manage {1} ", s.GetType().Name, s.StudentName);
            }
        }
    }
}
```

先看看这个School类，这个类又要访问Class类，又要访问Student类，直接跟两个类产生关系，这种写法耦合度就比较高，是违背迪米特原则的写法，可以将Manage拆分一下，变成School调用Class，Class调用Student，这样就能降低耦合，一个类只和另一个类联系，不会同时联系多个。

```csharp
public class School
{
    public int Id { get; set; }
    public string SchoolName { get; set; }
    public List<Class> ClassList { get; set; }

    public void Manage()
    {
        Console.WriteLine("Manage {0}", this.GetType().Name);
        foreach (Class c in this.ClassList)
        {
            Console.WriteLine(" {0}Manage {1} ", c.GetType().Name, c.ClassName);
            c.ManageClass();
        }
    }
}
public class Class
{
    public int Id { get; set; }
    public string ClassName { get; set; }

    public List<Student> StudentList { get; set; }


    public void ManageClass()
    {
        Console.WriteLine(" {0}Manage {1} ", this.GetType().Name, this.ClassName);
        foreach (Student s in this.StudentList)
        {
            s.ManageStudent();
        }

    }
}
public class Student
{
    public int Id { get; set; }
    public string StudentName { get; set; }
    public int Height { private get; set; }

    public int Salay;

    public void ManageStudent()
    {
        Console.WriteLine(" {0}Manage {1} ", this.GetType().Name, this.StudentName);
    }
}
```

这样就遵循了迪米特原则。实际运用中可以设计一个中间层，比如三层架构

# 开闭原则